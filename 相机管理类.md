**Creating a Camera Application**
**创建相机APP**

2018-01-02v4.4.1 4.4.1Github

If you come across any mistakes or bugs in this tutorial, please let us know using a Github issue or a post on the DJI forum. Please feel free to send us Github pull request and help us fix any issues.
如果您在本教程中遇到任何错误或BUG, 请使用 Github 或 DJI 论坛上的一个帖子告诉我们。 请随时发送 Github 请求, 并帮助我们解决任何问题。

This tutorial is designed for you to gain a basic understanding of the DJI Mobile SDK. It will implement the FPV view and two basic camera functionalities: Take Photo and Record video.
本教程是为您设计的, 以获得对 DJI Mobile SDK  的基本理解。 它将实现 FPV 视图和两个基本的摄像功能: 拍照和录像视频。

You can download the tutorial's final sample project from this Github Page.
您可以从这个 Github 页面下载教程的最终示例项目。

**Preparation**
**准备工作**

**Setup Android Development Environment**
**安装 Android 开发环境**

Throughout this tutorial we will be using Android Studio 3.0, which you can download from here: http://developer.android.com/sdk/index.html.
在本教程中, 我们将使用 Android Studio 3.0, 你可以在这里下载: http: / / developer.Android.com / sdk / index.html。

**Application Activation and Aircraft Binding in China**
**中国APP激活与无人机绑定**

For DJI SDK mobile application used in China, it's required to activate the application and bind the aircraft to the user's DJI account.
对于中国使用的 DJI SDK APP, 需要激活APP并将无人机绑定到用户的 DJI 帐户。

If an application is not activated, the aircraft not bound (if required), or a legacy version of the SDK (< 4.1) is being used, all camera live streams will be disabled, and flight will be limited to a zone of 100m diameter and 30m height to ensure the aircraft stays within line of sight.
如果一个APP没有被激活, 无人机不受管制(如果需要) , 或 SDK (4.1)的历史版本, 所有摄像头实时流都将被禁用, 飞行范围将限制在100米直径和30米高度范围内, 以确保无人机保持在视线范围内。

To learn how to implement this feature, please check this tutorial Application Activation and Aircraft Binding.
要学习如何实现这一特性, 请检查本教程APP激活和无人机绑定。

**Implementing the UI of Application**
**实现APPUI**

**Importing Maven Dependency**
**导入 Maven 依赖项**

Open Android Studio and select File -> New -> New Project to create a new project, named 'FPVDemo'. Enter the company domain and package name (Here we use "com.dji.FPVDemo") you want and press Next. Set the minimum SDK version as API 19: Android 4.4 (KitKat) for "Phone and Tablet" and press Next. Then select "Empty Activity" and press Next. Lastly, leave the Activity Name as "MainActivity", and the Layout Name as "activity_main", Press "Finish" to create the project.
打开Android Studio并选择File-New-New Project创建一个新项目, 命名为 FPVDemo。 输入您想要的公司域名和包名(这里我们使用"com.dji.FPVDemo")并按下一步。 将最小 SDK 版本设置为 API 19: Android 4.4(KitKat)的"手机和平板电脑", 然后按下一步。 然后选择"Empty Activity"并按下一步。 最后, 将Activity name设置为"MainActivity", 并将"layout name"作为"activity_main", 按"完成"来创建项目。

In our previous tutorial Importing and Activating DJI SDK in Android Studio Project, you have learned how to import the Android SDK Maven Dependency and activate your application. If you haven't read that previously, please take a look at it and implement the related features. Once you've done that, continue to implement the next features.
在我们之前的教程中, 你已经学会了如何导入 Android SDK Maven Dependency 并激活你的APP。 如果您没有学习这些教程, 请看一看并且实现相关的功能。 一旦这样做了, 继续实现下一个功能。

**Building the Layouts of Activity**
**建立活动的布局**

**1. Creating MApplication Class**
**1. 创建 MApplication 类**

Right click on the com.dji.FPVDemo, and select New->Java Class to create a new java class and name it as "MApplication".
右击 com.dji.FPVDemo, 选择 New-Java 类创建一个新的 Java 类, 并命名为"MApplication"。

Then, open the MApplication.java file and replace the content with the following:
然后, 打开 MApplication.java 文件, 并重写:
~~~
package com.dji.FPVDemo;
import android.app.Application;
import android.content.Context;
import com.secneo.sdk.Helper;
public class MApplication extends Application {
    private FPVDemoApplication fpvDemoApplication;
    @Override
    protected void attachBaseContext(Context paramContext) {
        super.attachBaseContext(paramContext);
        Helper.install(MApplication.this);
        if (fpvDemoApplication == null) {
            fpvDemoApplication = new FPVDemoApplication();
            fpvDemoApplication.setContext(this);
        }
    }
    @Override
    public void onCreate() {
        super.onCreate();
        fpvDemoApplication.onCreate();
    }
}
~~~
Here we firstly override the attachBaseContext() method to invoke the install() method of Helper class to load the SDK classes before using any SDK functionality. Failing to do so will result in unexpected crashes. Next, override the onCreate() method to invoke the onCreate() method of FPVDemoApplication.
在这里, 我们首先重写 attachbasecontext 方法来调用 Helper 类的install方法来在使用任何 SDK 功能之前加载 SDK 类。 如果不这样做, 将会导致意想不到的崩溃。 接下来, 重写 onCreate ()方法来调用 FPVDemoApplication 的 onCreate 方法。

**2. Creating FPVDemoApplication Class**
**2. 创建 FPVDemoApplication 类**

Right-click on the package com.dji.FPVDemo in the project navigator and choose New -> Java Class, Type in "FPVDemoApplication" in the Name field and select "Class" as Kind field content.
在项目导航中右击包 com.dji.FPVDemo, 在 Name 字段中选择 New-Java 类, 在 Name 字段中键入"FPVDemoApplication", 然后选择"Class"作为 Kind field content.。

Next, Replace the code of the "FPVDemoApplication.java" file with the following:
接下来, 将"FPVDemoApplication.java"文件的代码替换为:
~~~
package com.dji.FPVDemo;
import android.app.Application;
public class FPVDemoApplication extends Application{
    @Override
    public void onCreate() {
        super.onCreate();
    }
}
~~~
Here, we override the onCreate() method. We can do some settings when the application is created here.
在这里, 我们重写 onCreate ()方法。 我们可以在这里写入一些创建APP时需要的设置。

**3. Implementing MainActivity Class**
**3. 实现 MainActivity**

The MainActivity.java file is created by Android Studio by default. Let's replace the code of it with the following:
默认情况下, Android Studio 创建 MainActivity.java 文件。 让我们用以下代码取代它的代码:
~~~
public class MainActivity extends Activity implements TextureView.SurfaceTextureListener, View.OnClickListener {
    protected TextureView mVideoSurface = null;
    private Button mCaptureBtn, mShootPhotoModeBtn, mRecordVideoModeBtn;
    private ToggleButton mRecordBtn;
    private TextView recordingTime;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        setContentView(R.layout.activity_main);
        initUI();
    }
    @Override
    public void onResume() {
        super.onResume();
    }
    @Override
    public void onPause() {
        super.onPause();
    }
    @Override
    public void onStop() {
        super.onStop();
    }
    public void onReturn(View view){
        this.finish();
    }
    @Override
    protected void onDestroy() {
        super.onDestroy();
    }
    @Override
    public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) {
    }
    @Override
    public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) {
    }
    @Override
    public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) {
        return false;
    }
    @Override
    public void onSurfaceTextureUpdated(SurfaceTexture surface) {
    }
    private void initUI() {
        // init mVideoSurface
        mVideoSurface = (TextureView)findViewById(R.id.video_previewer_surface);
        recordingTime = (TextView) findViewById(R.id.timer);
        mCaptureBtn = (Button) findViewById(R.id.btn_capture);
        mRecordBtn = (ToggleButton) findViewById(R.id.btn_record);
        mShootPhotoModeBtn = (Button) findViewById(R.id.btn_shoot_photo_mode);
        mRecordVideoModeBtn = (Button) findViewById(R.id.btn_record_video_mode);
        
        if (null != mVideoSurface) {
            mVideoSurface.setSurfaceTextureListener(this);
        }
        
        mCaptureBtn.setOnClickListener(this);
        mRecordBtn.setOnClickListener(this);
        mShootPhotoModeBtn.setOnClickListener(this);
        mRecordVideoModeBtn.setOnClickListener(this);
        recordingTime.setVisibility(View.INVISIBLE);
        mRecordBtn.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
            @Override
            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
            
           }
        });
    }
    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.btn_capture:{
                break;
            }
            case R.id.btn_shoot_photo_mode:{
                break;
            }
            case R.id.btn_record_video_mode:{
                break;
            }
            default:
                break;
        }
    }
    
}
~~~
In the code shown above, we implement the following features:
在上面显示的代码中, 我们实现了以下特性:

1. Create the layout UI elements variables, including a TextureView mVideoSurface, three Buttons mCaptureBtn, mShootPhotoModeBtn, mRecordVideoModeBtn, one Toggle Button mRecordBtn and a TextView recordingTime.
1. 创建布局 UI 变量, 包括一个 TextureView mVideoSurface, 三个按钮 mCaptureBtn, mShootPhotoModeBtn, mrecordvideomdebtn, 一个切换按钮 mRecordBtn 和一个 TextView 记录时间。

2. Then invoke the initUI() method to initialize UI variables. And implement the setOnClickListener() method of Button for all the Buttons. Also implement the setOnCheckedChangeListener() method for Toggle Button.
 2.然后调用 initUI ()方法来初始化 UI 变量。并实现所有按钮的 setOnClickListener ()方法。 还实现了 Toggle 切换按钮的 setOnCheckedChangeListener ()方法。

3. Override the onClick() method to implement the three Buttons' click actions.
3. 重写 onClick ()方法来实现三个按钮的点击事件。

**4. Implementing the MainActivity Layout**
**4. 实现主活动布局**

Open the activity_main.xml layout file and replace the code with the following:
打开活动 main.xml 布局文件, 并用以下代码替换代码:
~~~
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">
    
    <TextureView
        android:id="@+id/video_previewer_surface"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_gravity="center"
        android:layout_centerHorizontal="true"
        android:layout_above="@+id/linearLayout" />
    
     <LinearLayout 
      android:layout_width="match_parent"
      android:layout_height="wrap_content"
      android:orientation="horizontal"
      android:layout_alignParentBottom="true"
         android:id="@+id/linearLayout">
    <Button
        android:id="@+id/btn_capture"
        android:layout_width="0dp"
        android:layout_weight="1"
        android:layout_gravity="center_vertical"
        android:layout_height="wrap_content"
        android:text="Capture" 
        android:textSize="12sp"/>
    <ToggleButton
        android:id="@+id/btn_record"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="Start Record"
        android:textOff="Start Record"
        android:textOn="Stop Record"
        android:layout_weight="1"
        android:layout_gravity="center_vertical"
        android:textSize="12dp"
        android:checked="false" />
     
    <Button
        android:id="@+id/btn_shoot_photo_mode"
        android:layout_width="0dp"
        android:layout_weight="1"
        android:layout_height="wrap_content"
        android:layout_gravity="center_vertical"
        android:text="Shoot Photo Mode"
        android:textSize="12sp"/>
    <Button
        android:id="@+id/btn_record_video_mode"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="Record Video Mode"
        android:layout_weight="1"
        android:layout_gravity="center_vertical" />
     </LinearLayout>
    <TextView
        android:id="@+id/timer"
        android:layout_width="150dp"
        android:layout_weight="1"
        android:layout_height="wrap_content"
        android:layout_gravity="center_vertical"
        android:layout_marginTop="23dp"
        android:gravity="center"
        android:textColor="#ffffff"
        android:layout_alignTop="@+id/video_previewer_surface"
        android:layout_centerHorizontal="true" />
</RelativeLayout>
~~~
In the xml file, we create a TextureView(id: video_previewer_surface) element to show the live video stream from the camera. Moreover, we implement a LinearLayout element to create the "Capture" Button(id: btn_capture), "Record" ToggleButton(id: btn_record), "Shoot Photo Mode" Button(id: btn_shoot_photo_mode) and "Record Video Mode" Button(id: btn_record_video_mode).
在 xml 文件中, 我们创建一个 TextureView 元素(id: video previewer surface)元素来显示摄像头中的视频流。 此外, 我们还实现了一个线性布局元素来创建"capture"拍照按钮(id: btn Capture)、"Record"切换按钮 (id: btn_record)、"拍照模式"按钮(id: btn_shoot_photo_mode)和"Record Video Mode"按钮(id: btn Record Video Mode)。

Lastly, we create a TextView(id: timer) element to show the record video time.
最后, 我们创建一个 TextView (id: timer)元素来显示记录视频时间。

**5. Implementing ConnectionActivity Class**
**5. 实现ConnectionActivity**

To improve the user experience, we had better create an activity to show the connection status between the DJI Product and the SDK, once it's connected, the user can press the OPEN button to enter the MainActivity.
为了改善用户体验, 我们最好创建一个活动来显示 DJI 无人机和 SDK 之间的连接状态, 一旦连接, 用户可以按打开按钮进入 MainActivity。

Now let's Right-click on the package com.dji.FPVDemo in the project navigator and choose New -> Activity -> Basic Activity, Type in "ConnectionActivity" in the "Activity Name" field and press "Finish" button.
现在, 右击com.dji.FPVDemo, 选择"New-Activity-Basic Activity, 输入"ConnectionActivity", 然后按"完成"按钮。

Next, replace the code of the "ConnectionActivity.java" file with the following:
接下来, 将"ConnectionActivity.java"文件的代码替换为:
~~~
public class ConnectionActivity extends Activity implements View.OnClickListener {
    private static final String TAG = ConnectionActivity.class.getName();
    private TextView mTextConnectionStatus;
    private TextView mTextProduct;
    private Button mBtnOpen;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        setContentView(R.layout.activity_connection);
        initUI();
    }
    @Override
    public void onResume() {
        Log.e(TAG, "onResume");
        super.onResume();
    }
    @Override
    public void onPause() {
        Log.e(TAG, "onPause");
        super.onPause();
    }
    @Override
    public void onStop() {
        Log.e(TAG, "onStop");
        super.onStop();
    }
    public void onReturn(View view){
        Log.e(TAG, "onReturn");
        this.finish();
    }
    @Override
    protected void onDestroy() {
        Log.e(TAG, "onDestroy");
        super.onDestroy();
    }
    private void initUI() {
        mTextConnectionStatus = (TextView) findViewById(R.id.text_connection_status);
        mTextProduct = (TextView) findViewById(R.id.text_product_info);
        mBtnOpen = (Button) findViewById(R.id.btn_open);
        mBtnOpen.setOnClickListener(this);
        mBtnOpen.setEnabled(false);
    }
    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.btn_open: {
                break;
            }
            default:
                break;
        }
    }
}
~~~
In the code shown above, we implement the following features:
在上面显示的代码中, 我们实现了以下特性:

Create the layout UI elements variables, including two TextureViews mTextConnectionStatus, mTextProduct, and one Button mBtnOpen.
创建布局 UI 元素变量, 包括两个 TextureViews mTextConnectionStatus, mTextProduct 和 一个按钮 mBtnOpen。

In the onCreate() method, we invoke the initUI() methods to initialize the UI elements.
在onCreate()方法中, 我们调用 initUI ()方法来初始化 UI 元素。

Next, implement the initUI() method to initialize the three TextViews and the Button. Then invoke setOnClickListener() method of mBtnOpen and pass this as the param.
接下来, 实现 initUI ()方法来初始化三个TextView和button。 然后调用 mBtnOpen 的 setOnClickListener 方法, 传入This作为参数。

Lastly, override the onClick() method to implement the Button's click action.
最后, 重写 onClick 方法来实现按钮的点击操作。

**6. Implementing the ConnectionActivity Layout**
**6. 这是一个很好的示例。 实现连接活动布局**

Open the activity_connection.xml layout file and replace the code with the following:
打开activity_connection.xml, 并用以下代码取代代码:
~~~
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">
    <TextView
        android:id="@+id/text_connection_status"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:gravity="center"
        android:text="Status: No Product Connected"
        android:textColor="@android:color/black"
        android:textSize="20dp"
        android:textStyle="bold"
        android:layout_alignBottom="@+id/text_product_info"
        android:layout_centerHorizontal="true"
        android:layout_marginBottom="89dp" />
    <TextView
        android:id="@+id/text_product_info"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="270dp"
        android:text="@string/product_information"
        android:textColor="@android:color/black"
        android:textSize="20dp"
        android:gravity="center"
        android:textStyle="bold"
        />
    <Button
        android:id="@+id/btn_open"
        android:layout_width="150dp"
        android:layout_height="55dp"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="350dp"
        android:background="@drawable/round_btn"
        android:text="Open"
        android:textColor="@color/colorWhite"
        android:textSize="20dp"
        />
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="430dp"
        android:text="@string/sdk_version"
        android:textSize="15dp"
        android:id="@+id/textView2" />
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textAppearance="?android:attr/textAppearanceSmall"
        android:text="DJIFPVDemo"
        android:id="@+id/textView"
        android:layout_marginTop="58dp"
        android:textStyle="bold"
        android:textSize="20dp"
        android:textColor="@color/colorBlack"
        android:layout_alignParentTop="true"
        android:layout_centerHorizontal="true" />
</RelativeLayout>
~~~
In the xml file, we create four TextViews and one Button within a RelativeLayout. We use the TextView(id: text_connection_status) to show the product connection status and use the TextView(id:text_product_info) to show the connected product name. The Button(id: btn_open) is used to open the MainActivity.
在 xml 文件中, 我们在RelativeLayout中创建了四个 TextViews 和一个 Button。 我们使用 TextView (id: text connection status)来显示无人机连接状态, 并使用 TextView (id: text product info)来显示连接的无人机名称。 按钮(id: btn open)用于打开 MainActivity。

**7. Configuring the Resource XMLs**
**7. 配置XMLs**

Once you finish the above steps, let's copy all the images file from this Github sample project's drawable folder (app->src->main->res->drawable) to the same folder in your project.
完成上述步骤后, 让我们将这个 Github 示例项目的drawable文件夹(app-src-main-res-drawable)复制到项目中的同一个文件夹。
![](https://devcn.djicdn.com/images/tutorials-and-samples/Android/FPVDemo/imageFiles-60f3d6b355.png)
imageFiles

Moreover, open the "colors.xml" file and update the content as shown below:
此外, 打开"colors.xml"文件并更新如下所示的内容:
~~~
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="colorWhite">#FFFFFF</color>
    <color name="colorBlack">#000000</color>
    <color name="colorPrimary">#3F51B5</color>
    <color name="colorPrimaryDark">#303F9F</color>
    <color name="colorAccent">#FF4081</color>
</resources>
~~~
Furthermore, open the "strings.xml" file and replace the content with the followings:
此外, 打开"strings.xml"文件并用下面的内容替换内容:
~~~
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">DJI FPV Demo</string>
    <string name="action_settings">Settings</string>   
    <string name="disconnected">Disconnected</string>
    <string name="product_information">Product Information</string>
    <string name="connection_loose">Status: No Product Connected</string>
    <string name="sdk_version">DJI SDK Version: 3.3</string>
</resources>
~~~
Lastly, open the "styles.xml" file and replace the content with the followings:
最后, 打开"styles.xml"文件, 用下面的内容替换:
~~~
<resources>
    <!-- Base application theme. -->
    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
        <!-- Customize your theme here. -->
        <item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>
    </style>
</resources>
~~~
Now, if you open the activity_main.xml file, and click on the Design tab on the bottom left, you should see the preview screenshots of MainActivity and ConnectionActivity as shown below:
现在, 如果你打开活动 main.xml 文件, 点击左下角的design, 你就会看到 MainActivity 和 ConnectionActivity 的预览截图, 如下所示:

ConnectionActivity 连接活动
![](https://devcn.djicdn.com/images/tutorials-and-samples/Android/FPVDemo/connectionActivityImage-8017851e69.png)
MainActivity 主要活动
![](https://devcn.djicdn.com/images/tutorials-and-samples/Android/FPVDemo/mainActivityImage-5df47d9447.png)
For more details, please check the Github source code of this tutorial.
有关详细信息, 请查看本教程的 Github 源代码。

**Registering the Application**
**登记申请**

After you finish the above steps, let's register our application with the App Key you apply from DJI Developer Website. If you are not familiar with the App Key, please check the Get Started.
完成上述步骤后, 用APP KEY来注册我们的APP。 如果您不知道APP KEY, 请检查 Get Started。

1. Let's open the AndroidManifest.xml file and add the following elements on top of the application element:
1. 让我们打开 AndroidManifest.xml 文件, 添加以下元素:
~~~
<uses-permission android:name="android.permission.BLUETOOTH" />
<uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
<uses-permission android:name="android.permission.VIBRATE" />
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
<uses-permission android:name="android.permission.WAKE_LOCK" />
<uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
<uses-permission android:name="android.permission.CHANGE_WIFI_STATE" />
<uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS" />
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />
<uses-permission android:name="android.permission.READ_PHONE_STATE" />
<uses-feature android:name="android.hardware.camera" />
<uses-feature android:name="android.hardware.camera.autofocus" />
<uses-feature
    android:name="android.hardware.usb.host"
    android:required="false" />
<uses-feature
    android:name="android.hardware.usb.accessory"
    android:required="true" />
~~~
Here, we request permissions that the application must be granted in order for it to register DJI SDK correctly. Also, we declare the camera and USB hardwares which are used by the application.
在这里, 我们必须授予APP权限以便它正确地注册 DJI SDK。 同时, 我们声明APP使用的摄像头和 USB 硬件。

Next, add the android:name=".MApplication" at the beginning of the application element:
接下来, 在application开头处添加android:name=".MApplication":
~~~
<application
    android:name=".MApplication"
    android:allowBackup="true"
    android:icon="@mipmap/ic_launcher"
    android:label="@string/app_name"
    android:supportsRtl="true"
    android:theme="@style/AppTheme">
~~~
Moreover, let's add the following elements as childs of element on top of the "ConnectionActivity" activity element as shown below:
此外, 更改"ConnectionActivity"，如下所示:
~~~
<!-- DJI SDK -->
<uses-library android:name="com.android.future.usb.accessory" />
<meta-data
    android:name="com.dji.sdk.API_KEY"
    android:value="Please enter your APP Key here." />
<activity
    android:name="dji.sdk.sdkmanager.DJIAoaControllerActivity"
    android:theme="@android:style/Theme.Translucent" >
    <intent-filter>
        <action android:name="android.hardware.usb.action.USB_ACCESSORY_ATTACHED" />
    </intent-filter>
    <meta-data
        android:name="android.hardware.usb.action.USB_ACCESSORY_ATTACHED"
        android:resource="@xml/accessory_filter" />
</activity>
<service android:name="dji.sdk.sdkmanager.DJIGlobalService" >
</service>
<!-- DJI SDK -->
~~~
In the code above, you should substitute your App Key of the application for "Please enter your App Key here." in the value attribute under the android:name="com.dji.sdk.API_KEY" attribute.
在上面的代码中, 您应该用APP KEY替换"Please enter your App Key here" 

Lastly, update the "MainActivity" and "ConnectionActivity" activity elements as shown below:
最后, 更新"MainActivity"和"ConnectionActivity", 如下所示:
~~~
<activity android:name=".ConnectionActivity"
    android:configChanges="orientation"
    android:screenOrientation="portrait">
    <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
    </intent-filter>
</activity>
<activity android:name=".MainActivity"
    android:screenOrientation="landscape"></activity>
~~~
In the code above, we add the attributes of "android:screenOrientation" to set "ConnectionActivity" as portrait and set "MainActivity" as landscape.
在上面的代码中, 我们添加了"android: screenOrientation"的属性来设置"ConnectionActivity"为portrait, 并将"MainActivity"设置为landscape。

2. After you finish the steps above, open the "FPVDemoApplication.java" file and replace the code with the same file in the Github Source Code, here we explain the important parts of it:
2. 在完成上面的步骤之后, 打开"FPVDemoApplication.java"文件, 并在 Github 源代码中用相同的文件替换代码, 这里我们将解释其中的重要部分:
~~~
@Override
public void onCreate() {
    super.onCreate();
    mHandler = new Handler(Looper.getMainLooper());
    mDJIComponentListener = new BaseComponent.ComponentListener() {
        @Override
        public void onConnectivityChange(boolean isConnected) {
            notifyStatusChange();
        }
    };
    mDJIBaseProductListener = new BaseProduct.BaseProductListener() {
        @Override
        public void onComponentChange(BaseProduct.ComponentKey key, BaseComponent oldComponent, BaseComponent newComponent) {
            if(newComponent != null) {
                newComponent.setComponentListener(mDJIComponentListener);
            }
            notifyStatusChange();
        }
        @Override
        public void onConnectivityChange(boolean isConnected) {
            notifyStatusChange();
        }
    };
    /**
     * When starting SDK services, an instance of interface DJISDKManager.DJISDKManagerCallback will be used to listen to
     * the SDK Registration result and the product changing.
     */
    mDJISDKManagerCallback = new DJISDKManager.SDKManagerCallback() {
        //Listens to the SDK registration result
        @Override
        public void onRegister(DJIError error) {
            if(error == DJISDKError.REGISTRATION_SUCCESS) {
                Handler handler = new Handler(Looper.getMainLooper());
                handler.post(new Runnable() {
                    @Override
                    public void run() {
                        Toast.makeText(getApplicationContext(), "Register Success", Toast.LENGTH_LONG).show();
                    }
                });
                DJISDKManager.getInstance().startConnectionToProduct();
            } else {
                Handler handler = new Handler(Looper.getMainLooper());
                handler.post(new Runnable() {
                    @Override
                    public void run() {
                        Toast.makeText(getApplicationContext(), "Register sdk fails, check network is available", Toast.LENGTH_LONG).show();
                    }
                });
            }
            Log.e("TAG", error.toString());
        }
        //Listens to the connected product changing, including two parts, component changing or product connection changing.
        @Override
        public void onProductChange(BaseProduct oldProduct, BaseProduct newProduct) {
            mProduct = newProduct;
            if(mProduct != null) {
                mProduct.setBaseProductListener(mDJIBaseProductListener);
            }
            notifyStatusChange();
        }
    };
    //Check the permissions before registering the application for android system 6.0 above.
    int permissionCheck = ContextCompat.checkSelfPermission(getApplicationContext(), android.Manifest.permission.WRITE_EXTERNAL_STORAGE);
    int permissionCheck2 = ContextCompat.checkSelfPermission(getApplicationContext(), android.Manifest.permission.READ_PHONE_STATE);
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M || (permissionCheck == 0 && permissionCheck2 == 0)) {
        //This is used to start SDK services and initiate SDK.
        DJISDKManager.getInstance().registerApp(getApplicationContext(), mDJISDKManagerCallback);
        Toast.makeText(getApplicationContext(), "registering, pls wait...", Toast.LENGTH_LONG).show();
    } else {
        Toast.makeText(getApplicationContext(), "Please check if the permission is granted.", Toast.LENGTH_LONG).show();
    }
}
~~~
Here, we implement several features:
在这里, 我们实现了几个特性:

  1.We override the onCreate() method to initialize the mHandler, mDJIComponentListener, mDJIBaseProductListener and mDJISDKManagerCallback instance variables and implement their callback methods.
我们重写 onCreate 方法来初始化 mHandler、 mDJIComponentListener、 mDJIBaseProductListener 和 mDJISDKManagerCallback 实例变量, 并实现它们的回调方法。

  2.For the two interface methods of BaseProductListener, we use the onComponentChange() method to check the product component change status and invoke the notifyStatusChange() method to notify status changes. Also, you can use the onConnectivityChange() method to notify the product connectivity changes.
对于 BaseProductListener 的两个接口方法, 我们使用 onComponentChange ()方法来检查无人机组件的更改状态, 并调用 notifingstatuschange ()方法来通知状态更改。 此外, 您可以使用 onConnectivityChange 方法来通知无人机的连接变化。

  3.For the two interface methods of SDKManagerCallback. we use the onRegister() method to check the Application registration status and show text message here. Using the onProductChange() method, we can check the product connection status and invoke the notifyStatusChange() method to notify status changes.
针对 SDKManagerCallback 的两种接口方法。 我们使用 onRegister ()方法来检查APP的注册状态, 并在这里显示文本消息。 使用 onProductChange ()方法, 我们可以检查无人机连接状态, 并调用 notifingstatuschange ()方法来通知状态更改。

  4.Check the permissions of WRITE_EXTERNAL_STORAGE and READ_PHONE_STATE, then invoke the registerApp() method of DJISDKManager to register the application.
检查 WRITE external storage 和 READ phone 状态的权限, 然后调用 DJISDKManager 的 registerApp ()方法来注册APP。

Now let's build and run the project and install it to your Android device. If everything goes well, you should see the "Register Success" textView like the following screenshot when you register the app successfully.
现在, 让我们建立并运行这个项目并把它安装到你的 Android 设备上。 如果一切顺利, 当你成功注册APP时, 你应该会看到"注册成功"文本, 就像下面的截图一样。
![](https://devcn.djicdn.com/images/tutorials-and-samples/Android/FPVDemo/registerSuccess-ca1ce1e377.png)
registerSuccess

Important: Please initialize the DJI Android SDK class objects inside the onCreate() method after the SDK classes are loaded, failing to do so will result in unexpected crashes.
重要: 请在 onCreate ()方法中初始化 DJI Android SDK 类对象, 在加载 SDK 类后, 如果没有这样做, 将导致意外崩溃。

For more details of registering your application, please check this tutorial: Importing and Activating DJI SDK in Android Studio Project.
有关注册APP的详细信息, 请点击这个教程: 在 Android Studio项目中导入和激活 DJI SDK。

**Working on the ConnectionActivity**

Once you finish the steps above, let's open the "ConnectionActivity.java" file and create several variables for checking permission and registration above the onCreate() method:
一旦完成上面的步骤, 让我们打开"ConnectionActivity.java"文件, 并创建一些变量来在 onCreate ()方法中检查权限和注册:
~~~
private static final String[] REQUIRED_PERMISSION_LIST = new String[]{
        Manifest.permission.VIBRATE,
        Manifest.permission.INTERNET,
        Manifest.permission.ACCESS_WIFI_STATE,
        Manifest.permission.WAKE_LOCK,
        Manifest.permission.ACCESS_COARSE_LOCATION,
        Manifest.permission.ACCESS_NETWORK_STATE,
        Manifest.permission.ACCESS_FINE_LOCATION,
        Manifest.permission.CHANGE_WIFI_STATE,
        Manifest.permission.WRITE_EXTERNAL_STORAGE,
        Manifest.permission.BLUETOOTH,
        Manifest.permission.BLUETOOTH_ADMIN,
        Manifest.permission.READ_EXTERNAL_STORAGE,
        Manifest.permission.READ_PHONE_STATE,
};
private List<String> missingPermission = new ArrayList<>();
private AtomicBoolean isRegistrationInProgress = new AtomicBoolean(false);
private static final int REQUEST_PERMISSION_CODE = 12345;
~~~
Next, invoke the checkAndRequestPermissions() method in the onCreate() method and implement the following methods:
接下来, 在 onCreate ()方法中调用 checkandrequestpermission ()方法, 并实现以下方法:
~~~
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    checkAndRequestPermissions();
    setContentView(R.layout.activity_connection);
    initUI();
}
/**
 * Checks if there is any missing permissions, and
 * requests runtime permission if needed.
 */
private void checkAndRequestPermissions() {
    // Check for permissions
    for (String eachPermission : REQUIRED_PERMISSION_LIST) {
        if (ContextCompat.checkSelfPermission(this, eachPermission) != PackageManager.PERMISSION_GRANTED) {
            missingPermission.add(eachPermission);
        }
    }
    // Request for missing permissions
    if (!missingPermission.isEmpty() && Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        ActivityCompat.requestPermissions(this,
                missingPermission.toArray(new String[missingPermission.size()]),
                REQUEST_PERMISSION_CODE);
    }
}
/**
 * Result of runtime permission request
 */
@Override
public void onRequestPermissionsResult(int requestCode,
                                       @NonNull String[] permissions,
                                       @NonNull int[] grantResults) {
    super.onRequestPermissionsResult(requestCode, permissions, grantResults);
    // Check for granted permission and remove from missing list
    if (requestCode == REQUEST_PERMISSION_CODE) {
        for (int i = grantResults.length - 1; i >= 0; i--) {
            if (grantResults[i] == PackageManager.PERMISSION_GRANTED) {
                missingPermission.remove(permissions[i]);
            }
        }
    }
    // If there is enough permission, we will start the registration
    if (missingPermission.isEmpty()) {
        startSDKRegistration();
    } else {
        showToast("Missing permissions!!!");
    }
}
private void startSDKRegistration() {
    if (isRegistrationInProgress.compareAndSet(false, true)) {
        AsyncTask.execute(new Runnable() {
            @Override
            public void run() {
                showToast( "registering, pls wait...");
                DJISDKManager.getInstance().registerApp(getApplicationContext(), new DJISDKManager.SDKManagerCallback() {
                    @Override
                    public void onRegister(DJIError djiError) {
                        if (djiError == DJISDKError.REGISTRATION_SUCCESS) {
                            DJILog.e("App registration", DJISDKError.REGISTRATION_SUCCESS.getDescription());
                            DJISDKManager.getInstance().startConnectionToProduct();
                            showToast("Register Success");
                        } else {
                            showToast( "Register sdk fails, check network is available");
                        }
                        Log.v(TAG, djiError.getDescription());
                    }
                    @Override
                    public void onProductChange(BaseProduct oldProduct, BaseProduct newProduct) {
                        Log.d(TAG, String.format("onProductChanged oldProduct:%s, newProduct:%s", oldProduct, newProduct));
                    }
                });
            }
        });
    }
}
~~~
In the code shown above, we implement the following features:
在上面显示的代码中, 我们实现了以下特性:

  1.In the onCreate() method, we invoke the checkAndRequestPermissions() method to check if there is any missing permissions, and requests runtime permission if needed. Then invoke the initUI() methods to initialize the UI elements.
在 onCreate ()方法中, 我们调用 checkandrequestpermission ()方法来检查是否缺少权限, 并在需要时请求运行时权限。 然后调用 initUI ()方法来初始化 UI 元素。

  2.Next, override the onRequestPermissionsResult() method to check the result of runtime permission request. And then invoke the startSDKRegistration() method to register the application.
接下来, 重写 onRequestPermissionsResult 方法来检查运行时权限请求的结果。 然后调用 startSDKRegistration ()方法来注册APP。

  3.Furthermore, implement the startSDKRegistration() method and invoke the registerApp() method of DJISDKManager to register the application. If the registration is successful, invoke the startConnectionToProduct() method of DJISDKManager inside the onRegister() callback method to start the connection between SDK and the DJI Products.
此外, 实现startSDKRegistration()方法, 并调用 DJISDKManager 的 registerApp ()方法来注册APP。 如果注册成功, 请在 onRegister ()回调方法中调用 DJISDKManager 的 startConnectionToProduct 方法来启动 SDK 和 DJI 无人机之间的连接。

Once we finish the steps above, continue to add the code at the bottom of the onCreate() method:
一旦我们完成上面的步骤, 继续在 onCreate ()方法的底部添加代码:
~~~
// Register the broadcast receiver for receiving the device connection's changes.
IntentFilter filter = new IntentFilter();
filter.addAction(FPVDemoApplication.FLAG_CONNECTION_CHANGE);
registerReceiver(mReceiver, filter);
~~~

Here, we register the broadcast receiver for receiving the device connection's changes.
在这里, 我们注册了接收设备连接变化的广播接收器。

Next, add the following methods below the initUI() method:
接下来, 在 initUI ()方法之下添加以下方法:
~~~
protected BroadcastReceiver mReceiver = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context, Intent intent) {
        refreshSDKRelativeUI();
    }
};
@Override
protected void onDestroy() {
    Log.e(TAG, "onDestroy");
    unregisterReceiver(mReceiver);
    super.onDestroy();
}
private void refreshSDKRelativeUI() {
    BaseProduct mProduct = FPVDemoApplication.getProductInstance();
    if (null != mProduct && mProduct.isConnected()) {
        Log.v(TAG, "refreshSDK: True");
        mBtnOpen.setEnabled(true);
        String str = mProduct instanceof Aircraft ? "DJIAircraft" : "DJIHandHeld";
        mTextConnectionStatus.setText("Status: " + str + " connected");
        if (null != mProduct.getModel()) {
            mTextProduct.setText("" + mProduct.getModel().getDisplayName());
        } else {
            mTextProduct.setText(R.string.product_information);
        }
    } else {
        Log.v(TAG, "refreshSDK: False");
        mBtnOpen.setEnabled(false);
        mTextProduct.setText(R.string.product_information);
        mTextConnectionStatus.setText(R.string.connection_loose);
    }
}
~~~
In the code above, we implement the following features:
在上面的代码中, 我们实现了以下特性:

  1.Create the "BroadcastReceiver" and override its onReceive() method to invoke the refreshSDKRelativeUI() method to refresh the UI elements.
  1.创建"BroadcastReceiver"并重写 onReceive ()方法来调用refreshSDKRelativeUI()方法来刷新 UI 元素。

  2.We override the onDestroy() method and invoke the unregisterReceiver() method by passing the mReceiver variable to unregister the broadcast receiver.
  2.我们重写onDestroy()方法并通过给unregisterReceiver()方法传递mReceiver变量来注销广播接收器来调用该方法。

  3.In the refreshSDKRelativeUI() method, we check the BaseProduct's connection status by invoking isConnected() method. If the product is connected, we enable the mBtnOpen button, update the mTextConnectionStatus's text content and update the mTextProduct's content with product name. Otherwise, if the product is disconnected, we disable the mBtnOpen button and update the mTextProduct and mTextConnectionStatus textViews' content.
  3.在refreshSDKRelativeUI()方法中, 我们通过调用 isConnected ()方法检查 BaseProduct 的连接状态。 如果无人机是连接的, 我们启用 mBtnOpen 按钮, 更新 mTextConnectionStatus 的文本内容, 并使用无人机名更新 mTextProduct 的内容。 否则, 如果无人机被断开, 我们禁用 mBtnOpen 按钮, 并更新 mTextProduct 和 mTextConnectionStatus textViews 的内容。

Finally, let's implement the onClick() method of mBtnOpen button and the showToast() method as shown below:
最后, 让我们实现 mBtnOpen 按钮和 showToast 方法的 onClick ()方法, 如下所示:
~~~
@Override
public void onClick(View v) {
    switch (v.getId()) {
        case R.id.btn_open: {
            Intent intent = new Intent(this, MainActivity.class);
            startActivity(intent);
            break;
        }
        default:
            break;
    }
}
private void showToast(final String toastMsg) {
    runOnUiThread(new Runnable() {
        @Override
        public void run() {
            Toast.makeText(getApplicationContext(), toastMsg, Toast.LENGTH_LONG).show();
        }
    });
}
~~~
Here, we create an Intent object with the class of MainActivity and invoke the startActivity() method by passing intent object to start the MainActivity.
在这里, 我们使用 MainActivity 类创建一个 Intent 对象, 并通过传递 Intent 对象启动 MainActivity 来调用 startActivity 方法。

**Implementing the First Person View**
**实现第一人称视图**
Now, let's open the "MainActivity.java" file and declare the TAG and mReceivedVideoDataCallBack variables as shown below:
现在, 让我们打开"MainActivity.java"文件, 并声明 TAG 和 mReceivedVideoDataCallBack 变量如下:
~~~
private static final String TAG = MainActivity.class.getName();
protected VideoFeeder.VideoDataCallback mReceivedVideoDataCallBack = null;
~~~
Then update the onCreate() method as shown below:
然后更新 onCreate ()方法, 如下所示:
~~~
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    initUI();
    // The callback for receiving the raw H264 video data for camera live view
    mReceivedVideoDataCallBack = new VideoFeeder.VideoDataCallback() {
        @Override
        public void onReceive(byte[] videoBuffer, int size) {
            if (mCodecManager != null) {
                mCodecManager.sendDataToDecoder(videoBuffer, size);
            }
        }
    };
}
~~~
In the code above, we initialize the mReceivedVideoDataCallBack variable using VideoFeeder's VideoDataCallback(). Inside the callback, we override its onReceive() method to get the raw H264 video data and send them to mCodecManager for decoding.
在上面的代码中, 我们使用 VideoFeeder 的 VideoDataCallback ()初始化 mReceivedVideoDataCallBack 变量。 在回调中, 我们重写 onReceive ()方法获取原始 H264视频数据并发送给 mCodecManager 进行解码。

Next, let's implement the onProductChange() method invoke it in the onResume() method as shown below:
接下来, 让我们实现 onProductChange ()方法在 onResume ()方法中调用它, 如下所示:
~~~
protected void onProductChange() {
    initPreviewer();
}
@Override
public void onResume() {
    Log.e(TAG, "onResume");
    super.onResume();
    initPreviewer();
    onProductChange();
    if(mVideoSurface == null) {
        Log.e(TAG, "mVideoSurface is null");
    }
}
~~~
Furthermore, let's implement two important methods to show and reset the live video stream on our mVideoSurface TextureView:
此外, 让我们实现两个重要的方法来显示和重置我们 mvideofacetextureview 上的视频流:
~~~
private void initPreviewer() {
    BaseProduct product = FPVDemoApplication.getProductInstance();
    if (product == null || !product.isConnected()) {
        showToast(getString(R.string.disconnected));
    } else {
        if (null != mVideoSurface) {
            mVideoSurface.setSurfaceTextureListener(this);
        }
        if (!product.getModel().equals(Model.UNKNOWN_AIRCRAFT)) {
            VideoFeeder.getInstance().getPrimaryVideoFeed().setCallback(mReceivedVideoDataCallBack);
        }
    }
}
private void uninitPreviewer() {
    Camera camera = FPVDemoApplication.getCameraInstance();
    if (camera != null){
        // Reset the callback
            VideoFeeder.getInstance().getPrimaryVideoFeed().setCallback(null);
    }
}
~~~
In the initPreviewer() method, firstly, we check the product connection status and invoke the setSurfaceTextureListener() method of TextureView to set texture listener to MainActivity. Then check if VideoFeeder has video feeds and the video feed's size is larger than 0 and set the mReceivedVideoDataCallBack as its "callback". So once the camera is connected and receive video data, it will show on the mVideoSurface TextureView.
在 initPreviewer ()方法中, 首先, 我们检查无人机连接状态并调用 setSurfaceTextureListener ()方法来设置侦听器。然后检查 VideoFeeder 是否有视频源, 视频源的大小大于0, 并将 mReceivedVideoDataCallBack 设置为其"callBack"。 因此, 一旦摄像头连接并接收视频数据, 它就会显示在 mVideoSurface TextureView 上。

Moreover, we implement the uninitPreviewer() method to reset Camera's "VideoDataCallback" to null.
而且，我们实现了uninitPreviewer()将Camera的“VideoDataCallback”重置为null的方法。

Now, let's override the four SurfaceTextureListener interface methods as shown below:
现在，让我们重写四个SurfaceTextureListener接口方法，如下所示：
~~~
@Override
public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) {
    Log.e(TAG, "onSurfaceTextureAvailable");
    if (mCodecManager == null) {
        mCodecManager = new DJICodecManager(this, surface, width, height);
    }
}
@Override
public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) {
    Log.e(TAG, "onSurfaceTextureSizeChanged");
}
@Override
public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) {
    Log.e(TAG,"onSurfaceTextureDestroyed");
    if (mCodecManager != null) {
        mCodecManager.cleanSurface();
        mCodecManager = null;
    }
    return false;
}
@Override
public void onSurfaceTextureUpdated(SurfaceTexture surface) {
}
~~~
We init the mCodecManager variable in the onSurfaceTextureAvailable() method, then reset the mCodecManager and invoke its cleanSurface() method to reset the surface data.
在 onSurfaceTextureAvailable ()方法中初始化 mCodecManager 变量, 然后重置 mCodecManager 并调用cleanSurface()方法来重置 surface 数据。

For more detail implementations, please check the Github source code of this tutorial.
有关更详细的实现, 请检查本教程的 Github 源代码。

**Connecting to the Aircraft or Handheld Device**
**连接无人机或手持设备**

After you finish the steps above, please check this Connect Mobile Device and Run Application guide to run the application and view the live video stream from your DJI product's camera based on what we've finished of the application so far!
完成以上步骤后, 请检查 连接手机和运行APP 指南, 以运行APP, 并根据我们完成的APP来查看 DJI 无人机摄像头上的视频流！

**Enjoying the First Person View**
**享受第一人称视角**

If you can see the live video stream in the application, congratulations! Let's move forward.
如果你能在APP中看到实时视频流, 那么恭喜你！ 让我们进行下一步吧。
![](https://devcn.djicdn.com/images/tutorials-and-samples/Android/FPVDemo/fpv-4216d4e373.png)
fpv

**Implementing the Capture function**
**实现Capture function**

Now, let's override the onClick() method to implement the capture button click action:
现在, 让我们重写 onClick ()方法来实现capture按钮点击事件:
~~~
@Override
public void onClick(View v) {
    switch (v.getId()) {
        case R.id.btn_capture:{
            captureAction();
            break;
        }
        default:
            break;
    }
}
~~~
Then declare a handler variable and initialize it in the onCreate() method as shown below:
然后声明一个handler变量并在onCreate()方法中初始化它，如下所示：
~~~
private Handler handler;

handler = new Handler();
~~~
Next, implement the captureAction() method as shown below:
接下来, 实现 captureAction ()方法, 如下所示:
~~~
// Method for taking photo
private void captureAction(){
    final Camera camera = FPVDemoApplication.getCameraInstance();
    if (camera != null) {
        SettingsDefinitions.ShootPhotoMode photoMode = SettingsDefinitions.ShootPhotoMode.SINGLE; // Set the camera capture mode as Single mode
        camera.setShootPhotoMode(photoMode, new CommonCallbacks.CompletionCallback(){
                @Override
                public void onResult(DJIError djiError) {
                    if (null == djiError) {
                        handler.postDelayed(new Runnable() {
                            @Override
                            public void run() {
                                camera.startShootPhoto(new CommonCallbacks.CompletionCallback() {
                                    @Override
                                    public void onResult(DJIError djiError) {
                                        if (djiError == null) {
                                            showToast("take photo: success");
                                        } else {
                                            showToast(djiError.getDescription());
                                        }
                                    }
                                });
                            }
                        }, 2000);
                    }
                }
        });
    }
}
~~~

In the code above, firstly, we create a "ShootPhotoMode" variable and assign "ShootPhotoMode.SINGLE" to it. Then invoke the setShootPhotoMode() method of Camera to set the shoot photo mode. The camera shoot photo mode has several modes within its definition. You can use "AEB", "BURST", "HDR", etc for "ShootPhotoMode", for more details, please check SettingsDefinitions.ShootPhotoMode.
在上面的代码中, 首先, 我们创建一个"ShootPhotoMode"变量, 并给它设置"ShootPhotoMode.SINGLE"。然后调用摄像头的 setShootPhotoMode ()方法来设置拍摄照片模式。 摄像头拍照模式定义中有几种。 你可以使用"AEB"、"BURST"、"HDR"等来表示"ShootPhotoMode", 详情请查看 settingsdefinitions.ShootPhotoMode。

Next, implement the startShootPhoto() method of Camera inside the completion callback of setShootPhotoMode method to control the camera to shoot photo. Here, we invoke the postDelayed() method of Handler to delay the method execution for 2000 milliseconds since the camera need time to execute the setShootPhotoMode command.
接下来，在startShootPhoto()方法的完成回调中实现Camera的setShootPhotoMode方法来控制相机拍照。在这里，我们调用postDelayed()方法，Handler是因为相机需要时间来执行延迟为2000毫秒的方法执行setShootPhotoMode命令。

Finally, we override its onResult() method of startShootPhoto() to get the result and show the related texts to users.
最后，我们重写了startShootPhoto()的onResult()方法得到结果，并显示相关文本给用户。

Build and run your project and then try the shoot photo function. If the screen flashes after your press the Capture button, your capture function should work now.
建立并运行您的项目, 然后尝试拍照功能。 如果在按下拍照按钮后闪烁, 那么你的拍照功能现在应该可以工作了。

**Implementing the Record function**
**实现Record function**

**Switching Camera Mode**
**切换摄像头模式**

Before we go ahead to implement the record action method, let's implement the switch Camera Mode feature. Improve the onClick() method by adding button click actions for mShootPhotoModeBtn and mRecordVideoModeBtn as follows:
在我们开始实现 Record方法之前, 让我们先实现切换摄像头模式的功能。修改 onClick ()方法, 在mShootPhotoModeBtn 和 mRecordVideoModeBtn 中添加按钮点击操作逻辑:
~~~
@Override
public void onClick(View v) {
    switch (v.getId()) {
        case R.id.btn_capture:{
            captureAction();
            break;
        }
        case R.id.btn_shoot_photo_mode:{
            switchCameraMode(SettingsDefinitions.CameraMode.SHOOT_PHOTO);
            break;
        }
        case R.id.btn_record_video_mode:{
            switchCameraMode(SettingsDefinitions.CameraMode.RECORD_VIDEO);
            break;
        }
        default:
            break;
    }
}
~~~
Next, implement the switchCameraMode() method:
接下来, 实现 switchamode ()方法:
~~~
private void switchCameraMode(SettingsDefinitions.CameraMode cameraMode){
    Camera camera = FPVDemoApplication.getCameraInstance();
    if (camera != null) {
        camera.setMode(cameraMode, new CommonCallbacks.CompletionCallback() {
            @Override
            public void onResult(DJIError error) {
                if (error == null) {
                    showToast("Switch Camera Mode Succeeded");
                } else {
                    showToast(error.getDescription());
                }
            }
        });
        }
}
~~~
In the code above, we invoke the setMode() method of Camera and assign the cameraMode parameter to it. Then override the onResult() method to show the change camera mode result to the users.
在上面的代码中, 我们调用摄像头的 setMode 方法, 并将 cameraMode 参数给它。 然后重写 onResult 方法, 向用户显示更改摄像头模式的结果。

**Working on the Record Action**
**Record 动作**

Once we finish the switch camera mode feature, we can now implement the record feature. Let's improve the initUI() method by add the following code at the bottom of it:
一旦我们完成了切换摄像头模式的功能, 我们现在就可以实现记录功能。我们添加下面的代码来改进 initUI ()方法:
~~~
mRecordBtn.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
    @Override
    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
        if (isChecked) {
            recordingTime.setVisibility(View.VISIBLE);
            startRecord();
        } else {
            recordingTime.setVisibility(View.INVISIBLE);
            stopRecord();
        }
    }
});
~~~
Here, we implement the setOnCheckedChangeListener() method of ToggleButton mRecordBtn and override its onCheckedChanged() method to check the isChecked variable value, which means the toggle state of the button, and invoke the startRecord() and stopRecord() methods relatively.
在这里, 我们实现了 ToggleButton和 mRecordBtn 的 setOnCheckedChangeListener 方法, 并重写 onCheckedChanged 方法来检查 isChecked 变量值, 这意味着随着按钮的切换, 会相对调用 startRecord ()和 stopRecord ()方法。

Next, implement the startRecord() and stopRecord() methods as shown below:
接下来, 实现 startRecord ()和 stopRecord ()方法, 如下所示:
~~~
// Method for starting recording
private void startRecord(){
    final Camera camera = FPVDemoApplication.getCameraInstance();
    if (camera != null) {
        camera.startRecordVideo(new CommonCallbacks.CompletionCallback(){
            @Override
            public void onResult(DJIError djiError)
            {
                if (djiError == null) {
                    showToast("Record video: success");
                }else {
                    showToast(djiError.getDescription());
                }
            }
        }); // Execute the startRecordVideo API
    }
}
// Method for stopping recording
private void stopRecord(){
    Camera camera = FPVDemoApplication.getCameraInstance();
    if (camera != null) {
        camera.stopRecordVideo(new CommonCallbacks.CompletionCallback(){
            @Override
            public void onResult(DJIError djiError)
            {
                if(djiError == null) {
                    showToast("Stop recording: success");
                }else {
                    showToast(djiError.getDescription());
                }
            }
        }); // Execute the stopRecordVideo API
    }
}

~~~
In the code above, we invoke the startRecordVideo() and stopRecordVideo() methods of Camera to implement the start record and stop record features. And show the result messages to our user by overriding the onResult() methods.
在上面的代码中, 我们调用 startRecordVideo ()和 stopRecordVideo ()方法来实现开始记录并停止记录特性。 并通过重写 onResult 方法向用户显示结果消息。

Lastly, when the video starts recording, we should show the recording time info to our users. So let's add the following code to the bottom of onCreate() method as follows:
最后, 当视频开始录制时, 我们应该向我们的用户显示记录时间信息。 因此, 让我们将下面的代码添加到 onCreate ()方法的底部, 如下所示:
~~~
Camera camera = FPVDemoApplication.getCameraInstance();
if (camera != null) {
    camera.setSystemStateCallback(new SystemState.Callback() {
        @Override
        public void onUpdate(SystemState cameraSystemState) {
            if (null != cameraSystemState) {
                int recordTime = cameraSystemState.getCurrentVideoRecordingTimeInSeconds();
                int minutes = (recordTime % 3600) / 60;
                int seconds = recordTime % 60;
                final String timeString = String.format("%02d:%02d", minutes, seconds);
                final boolean isVideoRecording = cameraSystemState.isRecording();
                MainActivity.this.runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        recordingTime.setText(timeString);
                        /*
                         * Update recordingTime TextView visibility and mRecordBtn's check state
                         */
                        if (isVideoRecording){
                            recordingTime.setVisibility(View.VISIBLE);
                        }else
                        {
                            recordingTime.setVisibility(View.INVISIBLE);
                        }
                    }
                });
            }
        }
    });
}
~~~
Here, we implement the setSystemStateCallback() of Camera and override the onUpdate() method to get the current camera system state, we can call the getCurrentVideoRecordingTimeInSeconds() method of "SystemState" to get the record time info. Before we show the record time info to our users, we should convert it from seconds to "00:00" format including minutes and seconds. Lastly, we update the TextView recordingTime variable's text value with the latest record time info and update the visibility of recordingTime TextView in UI Thread.
在这里, 我们实现了摄像头的 setSystemStateCallback () , 并且重写 onUpdate 方法来获取当前的摄像系统状态, 我们可以调用 getCurrentVideoRecordingTimeInSeconds ()方法来获取记录时间信息。 在我们向用户显示记录时间信息之前, 我们应该将它从秒转换为"00:00"格式, 包括分钟和秒。 最后, 我们更新TextView 记录时间变量的文本值和最新的记录时间信息, 并在 UI 线程中更新记录时间文本。

For more details, please check the Github source code of this tutorial.
有关详细信息, 请查看本教程的 Github 源代码。

Now, let's build and run the project and check the functions. Here we use Mavic Pro as an example. You can try to play with the Capture, Record and Switch Camera WorkMode functions, here is a gif animation to demo these three functions:
现在, 让我们建立和运行这个项目并检查functions。 这里我们用 Mavic Pro 作为示例。 您可以尝试使用拍照、记录和切换摄像头工作模式等功能, 这里有一个 gif 动画演示这三个功能:
![](https://devcn.djicdn.com/images/tutorials-and-samples/Android/FPVDemo/demoAni-11af76e174.gif)
demoAni

Congratulations! Your Aerial FPV android app is complete, you can now use this app to control the camera of your DJI Product now.
恭喜你！ 你的FPV APP已经完成, 你现在可以使用这个APP来控制你的 DJI 无人机的摄像头。

**Summary**
**摘要**

In this tutorial, you’ve learned how to use DJI Mobile SDK to show the FPV View from the aircraft's camera and control the camera of DJI's Aircraft to shoot photo and record video. These are the most basic and common features in a typical drone mobile app: Capture and Record. However, if you want to create a drone app which is more fancy, you still have a long way to go. More advanced features should be implemented, including previewing the photo and video in the SD Card, showing the OSD data of the aircraft and so on. Hope you enjoy this tutorial, and stay tuned for our next one!
在本教程中, 您已经学会了如何使用 DJI Mobile SDK 从无人机的摄像头中显示 FPV View, 并控制 DJI 无人机的摄像头拍摄照片和录像。 这些是一个典型的无人机移动应用中最基本和最常见的功能: 拍摄和记录。 然而, 如果你想创建一个更加强大的无人机APP, 你还有很长的路要走。应该实现更高级的功能, 包括在 SD 卡中预览照片和视频, 显示无人机的 OSD 数据等等。 希望你喜欢这个教程, 并且为我们的下一篇文章做好准备！


如果您觉得文档翻译有不妥，欢迎到Github上发起push请求，
如果你觉得本文档对您有帮助，可以通过赞赏来帮助我持续维护文档
也可以扫描下面的二维码加我微信拉您进DJI Mobile SDK 开发者群 探讨DJI SDK开发相关问题
![](images/20180303_092058.jpg)