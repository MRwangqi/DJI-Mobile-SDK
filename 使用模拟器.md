**DJI Simulator Tutorial**
**Dji 模拟器教程**

2018-01-15v4.4.1 4.4.1Github

If you come across any mistakes or bugs in this tutorial, please let us know using a Github issue, a post on the DJI Forum. Please feel free to send us Github pull request and help us fix any issues.
如果您在本教程中遇到任何错误或BUG, 请使用 DJI 论坛或Github 来告诉我们。 请随时发送 Github 请求, 并帮助我们解决任何问题。

In this tutorial, you will learn how to use the DJISimulator in your Android Studio project using DJI Mobile SDK. With the help of Virtual Stick control, you can input Virtual Stick flight control data and check the changes of simulator state in real time.
在本教程中, 您将学习如何使用 DJI Mobile SDK 在你的 Android Studio 项目中使用 DJISimulator。在虚拟摇杆控制的帮助下, 您可以输入虚拟摇杆飞行控制数据, 并实时检查模拟器状态的变化。

You can download the tutorial's final sample project from this Github Page.
您可以从这个 Github 页面下载教程的最终示例项目。

We use Mavic Pro as an example to make this demo.
我们使用 Mavic Pro 作为示例来做这个演示。

Let's get started!
我们开始吧！

**Introduction**
**引言**

DJISimulator is used to control the aircraft in a simulated environment based on the virtual stick input. The simulated aircraft state information will also be displayed on the screen.
DJI Simulator是基于虚拟摇杆输入的模拟环境中控制无人机的。 模拟的无人机状态信息也会显示在屏幕上。

You can use the Simulator class in FlightController to control the simulation. It allows both manual and automated flights to be simulated without actually flying the aircraft.
您可以使用 FlightController 中的 Simulator 类来控制仿真。 它允许模拟手动和自动飞行, 而不必实际飞行无人机。

Additionally, simulator initialization, monitoring and termination can be controlled directly through the SDK allowing for application development in continuous integration environments.
此外, 模拟器的初始化、监控和终止可以通过 SDK 直接控制, 使APP在连续集成环境中得到开发。

**Application Activation and Aircraft Binding in China**
**中国APP激活与无人机绑定**

For DJI SDK mobile application used in China, it's required to activate the application and bind the aircraft to the user's DJI account.
对于中国使用的 DJI SDK APP, 需要激活APP并将无人机绑定到用户的 DJI 帐户。

If an application is not activated, the aircraft not bound (if required), or a legacy version of the SDK (< 4.1) is being used, all camera live streams will be disabled, and flight will be limited to a zone of 100m diameter and 30m height to ensure the aircraft stays within line of sight.
如果一个APP没有被激活, 无人机不受约束(如果需要) , 或 SDK (4.1)的历史版本, 所有摄像头实时流都将被禁用, 飞行范围将限制在100米直径和30米高度范围内, 以确保无人机保持在视线范围内。

To learn how to implement this feature, please check this tutorial Application Activation and Aircraft Binding.
要学习如何实现这一特性, 请检查本教程APP激活和无人机绑定。

**Implementing the UI of Application**
**实现APP界面**

**Importing Maven Dependency**
**导入 Maven 依赖项**

Open Android Studio and select File -> New -> New Project to create a new project, named "DJISimulatorDemo". Enter the company domain and package name (Here we use "com.dji.simulatorDemo") you want and press Next. Set the minimum SDK version as API 19: Android 4.4 (KitKat) for "Phone and Tablet" and press Next. Then select "Empty Activity" and press Next. Lastly, leave the Activity Name as "MainActivity", and the Layout Name as "activity_main", press "Finish" to create the project.
打开Android Studio并选择File-New-New Project创建一个名为"DJISimulatorDemo"的新项目。 输入您想要的公司域名和包名(这里我们使用"com.dji.simulatorDemo")并按下一步。 将最小 SDK 版本设置为 API 19: Android 4.4(KitKat)的"手机和平板电脑", 然后按下一步。 然后选择"Empty Activity"并按下一步。 最后, 将活动名留作"MainActivity", 并将"布局名称"作为"活动主体", 按"完成"来创建项目。

In our previous tutorial Importing and Activating DJI SDK in Android Studio Project, you have learned how to import the Android SDK Maven Dependency and activate your application. If you haven't read that previously, please take a look at it and implement the related features. Once you've done that, continue to implement the next features.
在我们之前的教程中, 你已经学会了如何导入 Android SDK Maven Dependency 并激活你的APP。 如果您以前没有读过这篇文章, 请看一看并且实现相关的功能。 一旦这样做了, 继续实现下一个功能。

**Building the Layouts of Activity**
**建立活动的布局**

**1. Implementing the Joystick Control**
**1. 实现操纵杆控制**

In order to input some simulated data, like pitch, roll, yaw and verticalThrottle, you may need a joystick control. Let's work on the implementation of it.
为了输入一些模拟数据, 如俯仰、横滚、偏航和油门, 您可能需要一个操纵杆控制。 让我们一起努力实现它。

We implement the joystick control base on an open source Github project OnScreenJoystick . You can download the Github project to get the OnScreenJoystick.java and OnScreenJoystickListener.java files or get them from this tutorial's Github Sample project. Now, copy and paste these two java files to the folder of "com.dji.simulatorDemo" on the left navigator as shown below:
我们在一个开源 Github 项目 OnScreenJoystick 上实现操纵杆控制。 你可以下载 Github 项目来获取 OnScreenJoystick.java 和 onscreenjoysticener.java 文件, 或者从本教程的 Github 示例项目中获取。 现在, 将这两个 java 文件复制粘贴到左侧导航器的"com.dji.simulatorDemo"文件夹中, 如下图所示:

onScreenJoystick

When you touch on the OnScreenJoystick view, the onTouch method in OnScreenJoystickListener will be called and you can get the "OnScreenJoystick" joystick object, and the x and y coordinate of the knob parameters from this method as shown below:
当你触摸 OnScreenJoystick 视图时, OnScreenJoystickListener 中的 onTouch 方法将被调用, 您可以从下面的方法得到"OnScreenJoystick"操纵杆对象和旋钮参数的 x 和 y 坐标, 如下所示:

/** Called when the joystick is touched.
 * @param joystick The joystick which has been touched.
 * @param pX The x coordinate of the knob. Values are between -1 (left) and 1 (right).
 * @param pY The y coordinate of the knob. Values are between -1 (down) and 1 (up).
 */
public void onTouch(final OnScreenJoystick joystick, final float pX, final float pY);
Note: The values for x coordinate of the knob are between -1 (left) and 1 (right), the values for y coordinate of the knob are between -1 (down) and 1 (up).
注意: 旋钮的 x 坐标值在 -1(左)和1(右)之间, 旋钮的 y 坐标值在 -1(下)和1(上)之间。

Next, copy and paste the joystick.png and joystick_bg.png files from this tutorial's Github sample project to the mipmap folder on the left navigator as shown below:
接下来, 复制粘贴 joystick.png 和 joystick bg.png 文件, 从本教程的 Github 示例项目到左侧导航器上的 mipmap 文件夹, 如下图所示:

joystickImages

**2. Implementing the UI Elements in MainActivity Class**
**2. 在 MainActivity 类中实现 UI 元素**

Now, let's open the MainActivity.java file and replace the code with the followings:

现在, 让我们打开 MainActivity.java 文件, 用下面的代码替换代码:

public class MainActivity extends Activity implements View.OnClickListener {
    private static final String TAG = MainActivity.class.getName();
    protected TextView mConnectStatusTextView;
    private Button mBtnEnableVirtualStick;
    private Button mBtnDisableVirtualStick;
    private ToggleButton mBtnSimulator;
    private Button mBtnTakeOff;
    private Button mBtnLand;
    private TextView mTextView;
    private OnScreenJoystick mScreenJoystickRight;
    private OnScreenJoystick mScreenJoystickLeft;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initUI();
    }
    @Override
    public void onResume() {
        Log.e(TAG, "onResume");
        super.onResume();
    }
    @Override
    public void onPause() {
        Log.e(TAG, "onPause");
        super.onPause();
    }
    @Override
    public void onStop() {
        Log.e(TAG, "onStop");
        super.onStop();
    }
    public void onReturn(View view){
        Log.e(TAG, "onReturn");
        this.finish();
    }
    @Override
    protected void onDestroy() {
        Log.e(TAG, "onDestroy");
        super.onDestroy();
    }
    private void initUI() {
        mBtnEnableVirtualStick = (Button) findViewById(R.id.btn_enable_virtual_stick);
        mBtnDisableVirtualStick = (Button) findViewById(R.id.btn_disable_virtual_stick);
        mBtnTakeOff = (Button) findViewById(R.id.btn_take_off);
        mBtnLand = (Button) findViewById(R.id.btn_land);
        mBtnSimulator = (ToggleButton) findViewById(R.id.btn_start_simulator);
        mTextView = (TextView) findViewById(R.id.textview_simulator);
        mConnectStatusTextView = (TextView) findViewById(R.id.ConnectStatusTextView);
        mScreenJoystickRight = (OnScreenJoystick)findViewById(R.id.directionJoystickRight);
        mScreenJoystickLeft = (OnScreenJoystick)findViewById(R.id.directionJoystickLeft);
        mBtnEnableVirtualStick.setOnClickListener(this);
        mBtnDisableVirtualStick.setOnClickListener(this);
        mBtnTakeOff.setOnClickListener(this);
        mBtnLand.setOnClickListener(this);
        mBtnSimulator.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
            @Override
            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
            }
        });
        mScreenJoystickLeft.setJoystickListener(new OnScreenJoystickListener(){
            @Override
            public void onTouch(OnScreenJoystick joystick, float pX, float pY) {
          }
        });
        mScreenJoystickRight.setJoystickListener(new OnScreenJoystickListener() {
            @Override
            public void onTouch(OnScreenJoystick joystick, float pX, float pY) {
            }
        });
    }
    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.btn_enable_virtual_stick:
                break;
            case R.id.btn_disable_virtual_stick:
                break;
            case R.id.btn_take_off:
                break;
            case R.id.btn_land:
                break;
            default:
                break;
        }
    }
}
In the code above, we implement the following features:

在上面的代码中, 我们实现了以下特性:

1. Create the layout UI elements variables, including two TextView mConnectStatusTextView, mTextView, four buttons mBtnEnableVirtualStick, mBtnDisableVirtualStick, mBtnTakeOff, mBtnLand, one Toggle Button mBtnSimulator and two OnScreenJoystick control mScreenJoystickRight and mScreenJoystickLeft.

1. 创建布局 UI 元素变量, 包括两个 TextView mConnectStatusTextView, mTextView, 四个按钮 mBtnEnableVirtualStick, mbtnter, mBtnLand, one Toggle Button mBtnSimulator 和两个 OnScreenJoystick 控件 mScreenJoystickRight 和 mscreenjoysticticleft。

2. In the onCreate() method, we request several permissions at runtime to ensure the SDK works well when the compile and target SDK version is higher than 22(Like Android Marshmallow 6.0 device and API 23). Then invoke the initUI() method to initialize UI variables and their listeners.

第二名。 在 onCreate ()方法中, 我们在运行时请求多个权限, 以确保 SDK 在编译和目标 SDK 版本高于22(如 Android M 6.0设备和 API 23)。 然后调用 initUI ()方法来初始化 UI 变量及其侦听器。

3. In the initUI() method, we first initialize the UI elements variables, then set the click listener of the four buttons to "this". Moreover, implement the onCheckedChanged() method of toggle button mBtnSimulator's "setOnCheckedChangeListener". Finally, implement the onTouch() method of the two OnScreenJoystick objects' "setJoystickListener".

3. 这是一个很好的示例。 在 initUI ()方法中, 我们首先初始化 UI 元素变量, 然后将四个按钮的单击侦听器设置为"此"。 此外, 实现切换按钮的 onCheckedChanged 方法, 即模拟器的"setOnCheckedChangeListener"。 最后, 实现 OnScreenJoystick 对象"setjoysticlistener"的 onTouch ()方法。

4. Override the onClick() method to implement the four buttons' click actions.

4. 这是一个很好的示例。 重写 onClick ()方法来实现四个按钮的单击操作。

**3. Implementing the MainActivity Layout**
**3. 这是一个很好的示例。 实现主活动布局**

Open the activity_main.xml layout file and replace the code with the following:

打开活动 main.xml 布局文件, 并用以下代码替换代码:

<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">
    <RelativeLayout
        android:id="@+id/main_title_rl"
        android:layout_width="fill_parent"
        android:layout_height="40dp"
        android:background="@color/black_overlay" >
        <ImageButton
            android:id="@+id/ReturnBtn"
            android:layout_width="wrap_content"
            android:layout_height="35dp"
            android:layout_alignParentLeft="true"
            android:layout_centerVertical="true"
            android:layout_marginLeft="5dp"
            android:adjustViewBounds="true"
            android:background="@android:color/transparent"
            android:onClick="onReturn"
            android:scaleType="centerInside"
            android:src="@drawable/selector_back_button" />
        <TextView
            android:id="@+id/ConnectStatusTextView"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_centerInParent="true"
            android:text="SimulatorDemo"
            android:textColor="@android:color/white"
            android:textSize="19sp" />
    </RelativeLayout>
    <TextView
        android:layout_marginTop="70dp"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerHorizontal="true"
        android:text="Simulator is off."
        android:id="@+id/textview_simulator"/>
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Enable Virtual Stick"
        style="@style/common_button"
        android:id="@+id/btn_enable_virtual_stick"
        android:layout_marginLeft="5dp"
        android:layout_alignTop="@+id/btn_start_simulator"
        android:layout_alignStart="@+id/directionJoystickRight"
        android:layout_marginTop="0dp" />
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Disable Virtual Stick"
        style="@style/common_button"
        android:id="@+id/btn_disable_virtual_stick"
        android:layout_below="@+id/btn_enable_virtual_stick"
        android:layout_alignStart="@+id/btn_enable_virtual_stick"
        android:layout_marginLeft="0dp"
        android:layout_alignEnd="@+id/btn_enable_virtual_stick" />
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Take Off"
        style="@style/common_button"
        android:id="@+id/btn_take_off"
        android:layout_alignTop="@+id/btn_disable_virtual_stick"
        android:layout_alignStart="@+id/btn_start_simulator"
        android:layout_marginTop="0dp"
        android:layout_alignEnd="@+id/btn_start_simulator" />
    <ToggleButton
        android:id="@+id/btn_start_simulator"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Start Simulator"
        android:textOff="Start Simulator"
        android:textOn="Stop Simulator"
        style="@style/common_button"
        android:layout_below="@+id/textview_simulator"
        android:layout_toEndOf="@+id/btn_enable_virtual_stick"
        android:layout_marginTop="107dp"
        android:layout_marginLeft="10dp" />
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Land"
        style="@style/common_button"
        android:id="@+id/btn_land"
        android:layout_alignTop="@+id/btn_take_off"
        android:layout_marginTop="0dp"
        android:layout_alignEnd="@+id/directionJoystickLeft"
        android:layout_toEndOf="@+id/btn_take_off"
        android:layout_marginLeft="10dp" />
    <com.dji.simulatorDemo.OnScreenJoystick
        android:id="@+id/directionJoystickRight"
        android:layout_width="130dp"
        android:layout_height="130dp"
        android:layout_alignParentLeft="true"
        android:layout_alignParentBottom="true"
        android:layout_marginBottom="10dp"
        android:layout_marginLeft="10dp"
        android:background="@mipmap/joystick_bg"/>
    <com.dji.simulatorDemo.OnScreenJoystick
        android:id="@+id/directionJoystickLeft"
        android:layout_width="130dp"
        android:layout_height="130dp"
        android:layout_alignParentRight="true"
        android:layout_alignParentBottom="true"
        android:layout_marginBottom="10dp"
        android:layout_marginRight="10dp"
        android:background="@mipmap/joystick_bg"/>
</RelativeLayout>
In the xml file, first, we implement the RelativeLayout element. We declare an ImageButton(id: ReturnBtnCamera) element to exit the application, and a TextView(id: ConnectStatusTextView) element to show the connection status text.

在 xml 文件中, 首先, 我们实现了相对元素。 我们声明 ImageButton 元素(id: ReturnBtnCamera)元素退出APP, 以及一个文本视图元素(id: ConnectStatusTextView)元素来显示连接状态文本。

Next, create a TextureView(id: textview_simulator) element to show the simulator state infos. Moreover, create the "Enable Virtual Stick" button(id: btn_enable_virtual_stick), "Disable Virtual Stick" button(id: btn_disable_virtual_stick), "Take Off" button(id: btn_take_off), "Land" button(id: btn_land). Moreover, create the "Start Simulator" toggle button(id: btn_start_simulator) and set its textOn and textOff params to "Start Simulator" and "Stop Simulator".

接下来, 创建一个 TextureView 元素(id: textviewsimulator)元素来显示模拟器状态信息。 此外, 还可以创建"启用虚拟棒"按钮(id: btn 启用虚拟棒)、"禁用虚拟棒"按钮(id: btn 禁用虚拟棒)、"Off"按钮(id: btn 起飞)、"Land"按钮(id: btn Land)。 此外, 创建"启动模拟器"切换按钮(id: btn 启动模拟器) , 并将其文本和文本插件设置为"启动模拟器"和"停止模拟器"。

Lastly, we create two OnScreenJoystick elements (id: directionJoystickRight) and (id:directionJoystickLeft) for joystick control.

最后, 我们创建两个 OnScreenJoystick 元素(id: directionJoystickRight)和(id: directiontionjoystickleft)来控制操纵杆。

**4. Configuring the Resources**
**4. 这是一个很好的示例。 配置资源**

Once you finish the above steps, let's add some resources files to the res folder on the left navigator of Android Studio.

一旦你完成了上面的步骤, 让我们把一些资源文件添加到 Android Studio 左侧导航器的 res 文件夹中。

Copy the following image and xml files from the tutorial Github Sample project's drawable folder to your project, they are used for the button's UI:

将下面的图片和 xml 文件从教程 Github 项目的可绘制文件夹到您的项目, 它们是用于按钮的 UI:

drawable

Next, open the "colors.xml" file and add the following code at the bottom to declare the black overlay color:

接下来, 打开"colors.xml"文件, 在底部添加下面的代码来声明黑色叠加颜色:

<color name="black_overlay">#66000000</color>
Moreover, open the "strings.xml" file and add the "success" string:

此外, 打开"strings.xml"文件并添加"success"字符串:

<string name="success">Success</string>
Lastly, open the "styles.xml" file and add the following code to declare the "common_button" style:

最后, 打开"styles.xml"文件, 并添加以下代码以声明"通用按钮"样式:

<!-- Common button style -->
<style name="common_button">
    <item name="android:layout_width">100dp</item>
    <item name="android:layout_height">45dp</item>
    <item name="android:layout_marginTop">10dp</item>
    <item name="android:background">@drawable/round_btn</item>
    <item name="android:paddingLeft">5dp</item>
    <item name="android:paddingRight">5dp</item>
    <item name="android:textAllCaps">false</item>
    <item name="android:textColor">@android:color/white</item>
    <item name="android:textSize">14sp</item>
</style>

**Implementing Registration in DJISimulatorApplication and MainActivity**
**在 djisimulatorapplicationandmainactivity 中实现注册**

Once you finish the above steps, let's register the application on DJI Developer Website and get the App Key. If you are not familiar with the App Key, please check Generate an App Key for details.

一旦你完成上述步骤, 让我们在 DJI 开发者网站注册APP, 并获得APP密钥。 如果您不熟悉APP密钥, 请检查"生成APP密钥"。

Moreover, please check the Creating an Camera Application tutorial and the sample project of this tutorial for the detailed implementations of the MApplication, DJISimulatorApplication and MainActivity.

此外, 请检查创建摄像头APP教程和本教程的示例项目, 以详细实现 MApplication, djisimulatorapplicationandmainactivity。

Now let's build and run the project and install it to your Android device. If everything goes well, you should see the "success" textView like the following screenshot when you register the app successfully.

现在, 让我们建立并运行这个项目并把它安装到你的 Android 设备上。 如果一切顺利, 当你成功地注册APP时, 你应该会看到"成功"文本。

registerSuccess

**Working on MainActivity class**
**在 MainActivity 类上工作**

**Update Product Connection Status**
**更新无人机连接状态**

Please check the sample project of this tutorial for the detailed implementations.

请检查本教程的示例项目, 以便详细实现。

Now let's build and run the project and install it to your Android device. Then connect the demo application to your Mavic Pro (Please check Run Application for more details), if everything goes well, you should see the title textView content updates to "MavicPro Connected" as shown below:

现在, 让我们建立并运行这个项目并把它安装到你的 Android 设备上。 然后将演示APP连接到您的 Mavic Pro (请检查运行APP更多的细节) , 如果一切顺利, 你应该看看标题 textviewcontent updates to"MavicPro Connected", 如下所示:

registerSuccess

**Implementing Virtual Stick Control**
**实现虚拟棒控制**

Since we have implemented the Joystick control, now let's continue to work on sending virtual stick flight control data to the aircraft. First, we create a FlightController variable mFlightController, a Timer variable mSendVirtualStickDataTimer, a SendVirtualStickDataTask(extends from TimerTask class) variable mSendVirtualStickDataTask and four float variables on top of onCreate() method as shown below:

既然我们已经实现了操纵杆控制, 现在让我们继续致力于向无人机发送虚拟飞行控制数据。 首先, 我们创建一个 FlightController 变量 mFlightController, 一个 Timer 变量 mSendVirtualStickDataTimer, 一个 SendVirtualStickDataTask (从 TimerTask 类扩展)变量 msendendalstickdatatask 和4个 float 变量, 如下图所示:

private FlightController mFlightController;
private Timer mSendVirtualStickDataTimer;
private SendVirtualStickDataTask mSendVirtualStickDataTask;
private float mPitch;
private float mRoll;
private float mYaw;
private float mThrottle;
We may use the mPitch, mRoll, mYaw and mThrottle variables to store the pitch, roll, yaw and vertical throttle virtual stick flight control data.

我们可以使用 mPitch, mRoll, mYaw 和 mThrottle 变量来存储俯仰、摇摆、偏航和垂直节流杆的飞行控制数据。

Next, create the initFlightController() method, invoke it in the onResume() method and implement the SendVirtualStickDataTask class as shown below:

接下来, 创建 initFlightController ()方法, 在 onResume ()方法中调用它, 并实现 SendVirtualStickDataTask 类, 如下所示:

private void initFlightController() {
    Aircraft aircraft = DJISimulatorApplication.getAircraftInstance();
    if (aircraft == null || !aircraft.isConnected()) {
        showToast("Disconnected");
        mFlightController = null;
        return;
    } else {
        mFlightController = aircraft.getFlightController();
    }
}
@Override
public void onResume() {
    Log.e(TAG, "onResume");
    super.onResume();
    updateTitleBar();
    initFlightController();
}
class SendVirtualStickDataTask extends TimerTask {
        @Override
        public void run() {
            if (mFlightController != null) {
                mFlightController.sendVirtualStickFlightControlData(
                        new FlightControlData(
                                mPitch, mRoll, mYaw, mThrottle
                        ), new CommonCallbacks.CompletionCallback() {
                            @Override
                            public void onResult(DJIError djiError) {
                            }
                        }
                );
            }
        }
    }
In the code above, we implement the following features:

在上面的代码中, 我们实现了以下特性:

1. In the initFlightController() method, we first check if the aircraft is not null and is connected, then invoke the getFlightController() method of Aircraft to get the mFlightController variable.

1. 在 initFlightController ()方法中, 我们首先检查无人机是否无效并且是否连接, 然后调用无人机的 getFlightController 方法获得 mFlightController 变量。

2. Next, extends from TimerTask class to create the SendVirtualStickDataTask class. Inside the class, override the run() method to invoke the sendVirtualStickFlightControlData() method of FlightController to send virtual stick flight control data. Here, we create the FlightControlData object from the four float variables declared before: mPitch, mRoll, mYaw and mThrottle.

第二名。 接下来, 从 TimerTask 类扩展到创建 SendVirtualStickDataTask 类。 在类中, 重写"运行"方法来调用 FlightController 的 sendVirtualStickFlightControlData ()方法来发送虚拟粘飞行控制数据。 在这里, 我们从前面声明的四个浮动变量中创建 FlightControlData 对象: mPitch, mRoll, mYaw 和 mThrottle。

Once you finish the above steps, let's implement the setJoystickListener() methods of mScreenJoystickLeft and mScreenJoystickRight variables at the bottom of initUI() method as shown below:

一旦你完成上面的步骤, 让我们实现 setjoysticlistener ()的 mscreenjoysticticleft 和 mscreenjoysticticright 变量的 setjoysticlistener 方法, 如下所示:

mScreenJoystickLeft.setJoystickListener(new OnScreenJoystickListener(){
    @Override
    public void onTouch(OnScreenJoystick joystick, float pX, float pY) {
        if(Math.abs(pX) < 0.02 ){
            pX = 0;
        }
        if(Math.abs(pY) < 0.02 ){
            pY = 0;
        }
        float pitchJoyControlMaxSpeed = 10;
        float rollJoyControlMaxSpeed = 10;
        mPitch = (float)(pitchJoyControlMaxSpeed * pX);
        mRoll = (float)(rollJoyControlMaxSpeed * pY);
        if (null == mSendVirtualStickDataTimer) {
            mSendVirtualStickDataTask = new SendVirtualStickDataTask();
            mSendVirtualStickDataTimer = new Timer();
            mSendVirtualStickDataTimer.schedule(mSendVirtualStickDataTask, 100, 200);
        }
    }
});
mScreenJoystickRight.setJoystickListener(new OnScreenJoystickListener() {
    @Override
    public void onTouch(OnScreenJoystick joystick, float pX, float pY) {
        if(Math.abs(pX) < 0.02 ){
            pX = 0;
        }
        if(Math.abs(pY) < 0.02 ){
            pY = 0;
        }
        float verticalJoyControlMaxSpeed = 2;
        float yawJoyControlMaxSpeed = 30;
        mYaw = (float)(yawJoyControlMaxSpeed * pX);
        mThrottle = (float)(verticalJoyControlMaxSpeed * pY);
        if (null == mSendVirtualStickDataTimer) {
            mSendVirtualStickDataTask = new SendVirtualStickDataTask();
            mSendVirtualStickDataTimer = new Timer();
            mSendVirtualStickDataTimer.schedule(mSendVirtualStickDataTask, 0, 200);
        }
    }
});
Here, we implement the following features:

在这里, 我们实现了以下特性:

1. Override the onTouch() method of setJoystickListener and filter the pX and pY variables' value by checking if they are less than 0.02. We should not send the virtual stick data to flight controller too frequently if the value is too small.

1. 重写 setjoysticlistener 的 onTouch ()方法, 通过检查是否小于0.02, 过滤 pX 和 pY 变量的值。 如果值太小, 我们不应该将虚拟棒数据发送到飞控。

2. Get the maximum velocity of pitch and roll control, then store them to pitchJoyControlMaxSpeed and rollJoyControlMaxSpeed variables. Since the value of pX is between -1 (left) and 1 (right), the value of pY is between -1 (down) and 1 (up), we multiply by using the pitchJoyControlMaxSpeed and rollJoyControlMaxSpeed values to update the mPitch and mRoll data. Here we take Mode 2(American mode) of remote controller as example.

第二名。 获得最大速度的俯仰和横滚控制, 然后将它们存储到 pitchjoucontrolmaxspeed 和 rollJoyControlMaxSpeed 变量。 由于 pX 值在 -1(左)和1(右)之间, pY 的值在 -1(下)和1(上)之间, 我们通过使用 pitchJoyControlMaxSpeed 和 rollJoyControlMaxSpeed 来乘积, 以更新 mPitch 和 mRoll 数据。 以遥控器的模式2(美国模式)为例。

3. Lastly, we check if mSendVirtualStickDataTimer is null, and create it by invoking the SendVirtualStickDataTask() method. Then, create the mSendVirtualStickDataTimer and invoke its schedule() method to trigger the timer by passing mSendVirtualStickDataTask variable, 0 milliseconds of delay and 200 milliseconds between subsequent executions.

3. 这是一个很好的示例。 最后, 我们检查 mSendVirtualStickDataTimer 是否为 null, 并通过调用 SendVirtualStickDataTask 方法来创建它。 然后, 创建 mSendVirtualStickDataTimer 并调用它的时间表()方法通过 mSendVirtualStickDataTask 变量、0毫秒的延迟和200毫秒的时间来触发计时器。

4. Similarly, implement the setJoystickListener() method of mScreenJoystickRight variable to update the mYaw and mThrottle values and trigger the timer to send virtual stick data to the aircraft's flight controller.

4. 这是一个很好的示例。 同样, 实现 mScreenJoystickRight 变量的 setjoysticlistener 方法来更新 mYaw 和 mThrottle 值, 并触发计时器将虚拟棒数据发送到无人机的飞控上。

Now, when you control the left and right joysticks, they will send the simulated virtual stick data (Including Yaw, Pitch, Roll and Vertical Throttle) to the flight controller of aircraft.

现在, 当你控制左右操纵杆时, 他们会将模拟的虚拟棒数据(包括偏航、俯仰、横滚和垂直油门)到无人机的飞控上。

Lastly, override the onClick() method to implement the enable and disable virtual stick control buttons click actions as shown below:

最后, 重写 onClick ()方法来实现启用和禁用虚拟棒控制按钮的操作如下所示:

@Override
  public void onClick(View v) {
     switch (v.getId()) {
        case R.id.btn_enable_virtual_stick:
            if (mFlightController != null){
                mFlightController.setVirtualStickModeEnabled(true, new CommonCallbacks.CompletionCallback() {
                    @Override
                    public void onResult(DJIError djiError) {
                        if (djiError != null){
                            showToast(djiError.getDescription());
                        }else
                        {
                            showToast("Enable Virtual Stick Success");
                        }
                    }
                });
            }
            break;
        case R.id.btn_disable_virtual_stick:
            if (mFlightController != null){
                mFlightController.setVirtualStickModeEnabled(false, new CommonCallbacks.CompletionCallback() {
                    @Override
                    public void onResult(DJIError djiError) {
                        if (djiError != null) {
                            showToast(djiError.getDescription());
                        } else {
                            showToast("Disable Virtual Stick Success");
                        }
                    }
                });
            }
            break;
        }
    }
This invoke the enableVirtualStickControlMode() and disableVirtualStickControlMode() methods of FlightController to enable and disable the virtual stick control mode.

该方法调用了光控制器的非线性粘性控制模式()和 disableVirtualStickControlMode ()方法来启用和禁用虚拟粘贴控制模式。

**Implementing DJISimulator**
**实现 DJISimulator**

Let's implement the DJISimulator feature now. In order to update the simulator state data in mTextView, we may need to implement the setStateCallback() method of DJISimulator in the initFlightController() method as shown below:

现在让我们来实现 DJISimulator 功能。 为了更新 mTextView 中的模拟器状态数据, 我们可能需要在 initFlightController ()方法中实现 setStateCallback ()方法, 如下所示:

private void initFlightController() {
    Aircraft aircraft = DJISimulatorApplication.getAircraftInstance();
    if (aircraft == null || !aircraft.isConnected()) {
        showToast("Disconnected");
        mFlightController = null;
        return;
    } else {
        mFlightController = aircraft.getFlightController();
        mFlightController.setRollPitchControlMode(RollPitchControlMode.VELOCITY);
        mFlightController.setYawControlMode(YawControlMode.ANGULAR_VELOCITY);
        mFlightController.setVerticalControlMode(VerticalControlMode.VELOCITY);
        mFlightController.setRollPitchCoordinateSystem(FlightCoordinateSystem.BODY);
        mFlightController.getSimulator().setStateCallback(new SimulatorState.Callback() {
            @Override
            public void onUpdate(final SimulatorState stateData) {
                new Handler(Looper.getMainLooper()).post(new Runnable() {
                    @Override
                    public void run() {
                        String yaw = String.format("%.2f", stateData.getYaw());
                        String pitch = String.format("%.2f", stateData.getPitch());
                        String roll = String.format("%.2f", stateData.getRoll());
                        String positionX = String.format("%.2f", stateData.getPositionX());
                        String positionY = String.format("%.2f", stateData.getPositionY());
                        String positionZ = String.format("%.2f", stateData.getPositionZ());
                        mTextView.setText("Yaw : " + yaw + ", Pitch : " + pitch + ", Roll : " + roll + "\n" + ", PosX : " + positionX +
                                ", PosY : " + positionY +
                                ", PosZ : " + positionZ);
                    }
                });
            }
        });
    }
}
In the code above, we override the onUpdate() method to get the lastest simulator state data, then invoke the getYaw(), getPitch(), getRoll(), getPositionX(), getPositionY() and getPositionZ() methods of SimulatorState to get the updated yaw, pitch, roll, positionX, positionY and positionZ values and show them in mTextView.

在上面的代码中, 我们重写 onUpdate 方法来获取最新的模拟器状态数据, 然后调用 getYaw () , getPitch () , getRoll () , getPositionX () , getPositionY ()和 getPositionZ ()方法获得更新的 yaw、 pitch、 roll、 positionX、 positionY 和 positionZ 值, 并在 mTextView 中显示。

Next, override the onCheckedChanged() method of mBtnSimulator toggleButton's setOnCheckedChangeListener() method as shown below:

接下来, 重写 mbt 模拟器的 onCheckedChanged 方法, 如下图所示:

mBtnSimulator.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
    @Override
    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
        if (isChecked) {
            mTextView.setVisibility(View.VISIBLE);
            if (mFlightController != null) {
                mFlightController.getSimulator()
                        .start(InitializationData.createInstance(new LocationCoordinate2D(23, 113), 10, 10),
                                new CommonCallbacks.CompletionCallback() {
                            @Override
                            public void onResult(DJIError djiError) {
                                if (djiError != null) {
                                    showToast(djiError.getDescription());
                                }else
                                {
                                    showToast("Start Simulator Success");
                                }
                            }
                        });
            }
        } else {
            mTextView.setVisibility(View.INVISIBLE);
            if (mFlightController != null) {
                mFlightController.getSimulator()
                        .stop(new CommonCallbacks.CompletionCallback() {
                                    @Override
                                    public void onResult(DJIError djiError) {
                                        if (djiError != null) {
                                            showToast(djiError.getDescription());
                                        }else
                                        {
                                            showToast("Stop Simulator Success");
                                        }
                                    }
                                }
                        );
            }
        }
    }
});
In the code above, we implement the following features:

在上面的代码中, 我们实现了以下特性:

1. If the mBtnSimulator toggle button is checked, then show the mTextView. Next, if the mFlightController is not null, we invoke the start() method of DJISimulator by passing a InitializationData with LocationCoordinate2D struct (lattitude 23 and longitude 113), updateFrequency 10 and satelliteCount 10 parameters to it. For more details of DJISimulatorInitializationData, please check the Android API Reference.

1. 如果检查了 mBtnSimulator 切换按钮, 然后显示 mTextView。 其次, 如果 mFlightController 不是 null, 我们通过使用 LocationCoordinate2D 结构(latalgate23 and longitude 113)、 updateFrequency 10和 satelliteCount 10参数的初始化数据, 调用 DJISimulator 的启动方法。 有关 djisulatorinitiationationdata 的详细信息, 请查看 Android API 参考。

2. Next, overide the onResult() method of start(), invoke showToast() method to show the start simulator result to the user.

第二名。 接下来, 在 onResult ()启动方法()上, 调用 showToast 方法向用户显示启动模拟器的结果。

3. Similarly, if the mBtnSimulator toggle button is not checked, then invoke the stop() method of DJISimulator to stop the simulator. Furthermore, override the onResult() method and invoke the showToast() method to show the stop simulator result to the user.

3. 这是一个很好的示例。 类似地, 如果不检查 mBtnSimulator 切换按钮, 则调用 DJISimulator 的停止方法来停止模拟器。 此外, 重写 onResult 方法并调用 showToast 方法来向用户显示停止模拟器的结果。

**Working on Takeoff and AutoLanding features**
**关于起飞和自动定位功能的研究**

Finally, let's add the following code at the bottom of onClick() method to implement the Take off and Land buttons' click actions as shown below:

最后, 让我们在 onClick ()方法的底部添加以下代码, 以实现如下所示的起飞和降落按钮的单击操作:

case R.id.btn_take_off:
    if (mFlightController != null){
        mFlightController.startTakeoff(
                new CommonCallbacks.CompletionCallback() {
                    @Override
                    public void onResult(DJIError djiError) {
                        if (djiError != null) {
                            showToast(djiError.getDescription());
                        } else {
                            showToast("Take off Success");
                        }
                    }
                }
        );
    }
    break;
case R.id.btn_land:
    if (mFlightController != null){
        mFlightController.startLanding(
                new CommonCallbacks.CompletionCallback() {
                    @Override
                    public void onResult(DJIError djiError) {
                        if (djiError != null) {
                            showToast(djiError.getDescription());
                        } else {
                            showToast("Start Landing");
                        }
                    }
                }
        );
    }
    break;
For the case of "R.id.btn_take_off", we invoke the startTakeoff() method of FlightController to send the take off command to the aircraft. Similiarly, for the case of "R.id.btn_land", we invoke the startLanding() method to send the auto landing command. It's just that simple and easy.

对于"R.id.btn 起飞"的情况, 我们调用 FlightController 的起飞起飞方法将起飞命令发送到无人机上。 同样, 对于"R.id.btn 土地"的情况, 我们调用 startLanding ()方法来发送自动降落命令。 就是这么简单简单。

We have gone through a long way in this tutorial, now let's build and run the project, connect the demo application to your Mavic Pro (Please check Run Application for more details) and check all the features we have implemented so far.

在这个教程中, 我们已经经历了很多, 现在让我们建立和运行这个项目, 将演示APP连接到您的 Mavic Pro (请检查运行APP更多的细节) , 并检查我们迄今为止已经实现的所有功能。

If everything goes well, you should see something similiar to the following gif animations like this:

如果一切顺利, 你应该看到类似于下面这些 gif 动画的东西:


If the demo application is connected with Mavic Pro successfully, you should see the title textView content updates to "MavicPro Connected".

如果演示APP与 Mavic Pro 成功连接, 您应该看到标题 textView 内容更新"MavicPro 连接"。

Press Enable Virtual Stick button to enable virtual stick control, then press Start Simulator to start the simulator.

按下启用虚拟棒控制按钮, 使虚拟棒控制, 然后按启动模拟器启动模拟器。

Moreover, press the Take Off button to send take off command to the aircraft, if the command executes successfully, you should see the PosZ value start to change, means that the aircraft is rising.

此外, 按下起飞按钮, 发送起飞命令到无人机, 如果指挥成功执行, 你应该看到 PosZ 值开始变化, 这意味着无人机正在上升。

Now you can drag the left and right virtual stick controls to simulate the flight behavious.

现在可以拖动左边和右边的虚拟棒控件来模拟飞行行为。

Lastly, press the Land button to make the aircraft start auto landing, once it finish, you may notice the PosZ value becomes "0.00". Press the Stop Simulator button to stop the simulator and then press Disable Virtual Stick to disable the virtual stick control.

最后, 按下陆地按钮, 使无人机开始自动降落, 一旦它完成, 你可能会注意到 PosZ 值变成"0.00"。 按下停止模拟器按钮来停止模拟器, 然后按下禁用虚拟棒来禁用虚拟棒控制。

**Summary**
**摘要**

In this tutorial, you've learned how to use the DJISimulator feature to simulate aircraft's flight behaviour in a simulated environment based on the virtual stick control input and show the changes of simulator state(Yaw,Pitch,Roll,PosX,PosY and PosZ) in real time. Also you've learned how to use Virtual Stick control to send virtual stick flight control data to the aircraft.

在本教程中, 您已经学会了如何使用 djisimator 特性来模拟无人机在模拟环境中的飞行行为, 并且实时显示了模拟器状态(Yaw, Pitch, Roll, PosX, PosY 和 PosZ)的变化。 同时, 你已经学会了如何使用虚拟摇杆控制来向无人机发送虚拟棒棒飞行控制数据。

This demo is a simple demonstration of using DJISimulator, to have a better user experience, you can create a 3D simulated environment using 3D game engine like Unity3D to show the simulated data and aircraft flight behavious inside your mobile application (Like the Flight Simulator in DJI Go app)!

这个演示是一个简单的使用 DJISimulator 的演示, 为了获得更好的用户体验, 你可以使用3D 游戏引擎创建一个3D 模拟环境, 来显示模拟数据和无人机在你的移动APP中的行为(就像 DJI Go APP中的飞行模拟器一样) ！

Furthermore, the DJISimulator allows for automated testing in continous integration environment(Like Jenkins), it would help your DJI-SDK based application testing process. Good luck, and hope you enjoyed this tutorial!

此外, DJISimulator 允许在连续集成环境中进行自动测试(如 Jenkins) , 这将有助于您的基于 dj-sdk 的APP测试过程。 祝你好运, 希望你喜欢这个教程！


如果您觉得文档翻译有不妥，欢迎到Github上发起push请求，
如果你觉得本文档对您有帮助，可以通过赞赏来帮助我持续维护文档
也可以扫描下面的二维码加我微信拉您进DJI Mobile SDK 开发者群 探讨DJI SDK开发相关问题
![](images/20180303_092058.jpg)