**Creating a TapFly and ActiveTrack Missions Application**
**创建 指点飞行和智能跟随 任务APP**

2018-01-15v4.4.1 4.4.1Github

In this tutorial, you will learn how to use the TapFly and ActiveTrack Missions of DJI Android SDK to create a cool application for Mavic Pro. Also, you will get familiar with ActiveTrackOperator, TapFlyMissionOperator and using the Simulator of DJI Assistant 2 for testing, which is convenient for you to test the missions indoor. We will use Android Studio 3.0 version for demo here. So let's get started!

在本教程中, 您将学习如何使用 DJI Android SDK 的 指点飞行和智能跟随 任务来为 Mavic Pro 创建一个很酷的APP。 此外, 您还可以熟悉 ActiveTrackOperator, tapflymissionatoroperator, 并使用 DJI 助手2的模拟器进行测试, 这对于测试室内任务是很方便的。 我们将使用 Android Studio 3.0版本在这里演示。 让我们开始吧！

You can download the tutorial's final sample code project from this Github Page.

您可以从这个 Github 页面下载教程的最终示例代码项目。

**Introduction**
**引言**

The TapFly and ActiveTrack missions bring you a more autonomous flying experience. They are originally supported by Phantom 4, now they are also supported by Mavic Pro, Phantom 4 Pro, Phantom 4 Advanced, Spark, M200 and Inspire 2.

指点飞行和智能跟随 飞行任务给你带来了更加自主的飞行体验。 它们最初由 Phantom 4支持, 现在他们也支持 Mavic Pro, Phantom 4 Pro, Phantom 4 Advanced, Spark, M200和 Inspire 2。

**TapFly Mission**
**飞蝼蛄任务**

Given a coordinate in the live video stream (which can come from a user tap), the aircraft will calculate and fly towards the coordinate's direction in the real world. During a flight, the aircraft will automatically detect and avoid obstacles. Also, the aircraft will stop flying in the direction if it reaches its radius limitation, the mission is stopped, the user pulls back on the pitch stick or if it comes to an obstacle it cannot bypass.

如果在实时视频流中得到一个坐标(可以来自用户的点击) , 无人机将计算并飞向真实世界中坐标的方向。 在飞行过程中, 无人机会自动检测和避障物。 同时, 如果无人机达到了它的半径限制, 它将停止飞行, 飞行任务停止, 用户退回到球杆上, 或者如果它遇到了无法绕过的障碍。

During the mission, you can use the remote controller's yaw stick to adjust the heading of the aircraft, which also adjusts the direction of flight to the new yaw.

在任务期间, 您可以使用遥控器的偏航杆来调整无人机的航向, 这也调整了飞往新航母的方向。

Here is a video for you to get the first impression of the TapFly Mission.

这里有一个视频, 你可以得到 TapFly 任务的第一印象。

**ActiveTrack Mission**
**智能跟随**

An ActiveTrack Mission allows an aircraft to track a moving subject using the vision system and without a GPS tracker on the subject. To use an ActiveTrack mission:

一个运动轨道飞行任务允许无人机使用视觉系统跟踪一个移动的目标, 而不需要在这个主题上安装 GPS 跟踪器。 使用 ActiveTrack 任务:

The main camera is used to track the target, so the gimbal cannot be adjusted during an ActiveTrack mission. During the mission, the aircraft can be manually flown with pitch, roll and throttle to move around the subject being tracked.

主摄像头用于跟踪目标, 所以在 ActiveTrack 任务中不能调整平衡框。 在执行任务期间, 无人机可以手动飞行, 用俯仰、横滚和油门来移动被追踪的目标。

Here is a video for you to get the first impression of the ActiveTrack Mission.

这里有一个视频, 你可以得到 ActiveTrack 任务的第一印象。

**Application Activation and Aircraft Binding in China**
**中国应用激活与无人机装订**

For DJI SDK mobile application used in China, it's required to activate the application and bind the aircraft to the user's DJI account.

对于中国使用的 DJI SDK 移动APP, 需要激活APP并将无人机绑定到用户的 DJI 帐户。

If an application is not activated, the aircraft not bound (if required), or a legacy version of the SDK (< 4.1) is being used, flight will be limited to a cylinder of 100m diameter and 30m height to ensure the aircraft stays within line of sight.

如果一个APP没有被激活, 无人机不受约束(如果需要的话) , 或 SDK (4.1)的遗留版本, 飞行将被限制在一个直径为100米和30米高的圆柱体上, 以确保无人机保持在视线范围内。

To learn how to implement this feature, please check this tutorial Application Activation and Aircraft Binding.

要学习如何实现这一特性, 请检查本教程APP激活和无人机绑定。

**Implementing the UI of Application**
**实现APP界面**

Now that you know the details of the two missions, we can start working on the application.

现在你已经知道了这两个任务的细节, 我们可以开始处理这个APP了。

**Importing Maven Dependency**
**导入 Maven 依赖项**

Open Android Studio and select File -> New -> New Project to create a new project, named 'P4MissionsDemo'. Enter the company domain and package name(Here we use "com.dji.P4MissionsDemo") you want and press Next. Set the minimum SDK version as API 19: Android 4.4 (KitKat) for "Phone and Tablet" and press Next. Then select "Empty Activity" and press Next. Lastly, leave the Activity Name as "MainActivity", and the Layout Name as "activity_main", Press "Finish" to create the project.

打开Android Studio并选择文件-新-新项目创建一个新项目, 命名为"P4MissionsDemo"。 输入您想要的公司域名和包名(这里我们使用"com.dji.P4MissionsDemo")并按下一步。 将最小 SDK 版本设置为 API 19: Android 4.4(KitKat)的"手机和平板电脑", 然后按下一步。 然后选择"空活动"并按下一步。 最后, 将活动名留作"MainActivity", 并将"布局名称"作为"活动主体", 按"完成"来创建项目。

In our previous tutorial Importing and Activating DJI SDK in Android Studio Project, you have learned how to import the Android SDK Maven Dependency and activate your application. If you haven't read that previously, please take a look at it and implement the related features. Once you've done that, continue to implement the next features.

在我们之前的教程中, 你已经学会了如何导入 Android SDK Maven Dependency 并激活你的APP。 如果您以前没有读过这篇文章, 请看一看并且实现相关的功能。 一旦这样做了, 继续实现下一个功能。

**Building the Layouts of Activities**
**建立活动的布局**

**1. Implementing MApplication and DJIDemoApplication**
**1. 实现 MApplication 和 DJIDemoApplication**
You can check the Creating an Camera Application tutorial and the sample project of this tutorial for the detailed implementations of the MApplication and DJIDemoApplication.

您可以检查创建一个摄像头APP教程和本教程的示例项目, 以详细实现 MApplication 和 DJIDemoApplication。

**2. Implementing DemoBaseActivity Class**
**2. 实现基于人口的活动类**
Similarly, create a new Empty Activity class with the name of "DemoBaseActivity" in the com.dji.p4MissionsDemo package. Remember to deselect the "Generate Layout File". Replace the code with the following, remember to import the related classes as Android Studio suggested:

同样, 在 com.dji.p4MissionsDemo 包中创建一个名为"DemoBaseActivity"的新的空活动类。 记得取消"生成布局文件"。 用下面的代码替换代码, 记住按照 Android Studio 的建议导入相关的类:

public class DemoBaseActivity extends FragmentActivity implements SurfaceTextureListener {
    protected TextView mConnectStatusTextView;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mConnectStatusTextView = (TextView) findViewById(R.id.ConnectStatusTextView);
    }
    @Override
    public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) {
    }
    @Override
    public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) {
    }
    @Override
    public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) {
        return false;
    }
    @Override
    public void onSurfaceTextureUpdated(SurfaceTexture surface) {
    }
}
We will use this activity class as our base class later. More details of the implementation will be done later.

稍后我们将使用这个活动类作为基础类。 更多的实施细节将在稍后完成。

**3. Creating the MainActivity**
**3. 这是一个很好的示例。 创建 MainActivity**

**Working on the MainActivity Class**
**在 MainActivity 类上工作**

For the implementation of the "MainActivity.java class, please check the Creating an Camera Application tutorial and the sample project of this tutorial.

为了实现"MainActivity.java 类", 请检查创建摄像头APP教程和本教程的示例项目。

**Implementing the MainActivity Layout**
**实现主活动布局**

Open the activity_main.xml layout file and replace the code with the following:

打开活动 main.xml 布局文件, 并用以下代码替换代码:

<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:keepScreenOn="true"
    android:orientation="vertical" >
    <RelativeLayout
        android:id="@+id/main_title_rl"
        android:layout_width="fill_parent"
        android:layout_height="40dp"
        android:background="@android:color/black" >
        <ImageButton
            android:id="@+id/ReturnBtnMain"
            android:layout_width="wrap_content"
            android:layout_height="35dp"
            android:layout_alignParentLeft="true"
            android:layout_centerVertical="true"
            android:layout_marginLeft="20dp"
            android:adjustViewBounds="true"
            android:background="@android:color/transparent"
            android:onClick="onReturn"
            android:scaleType="centerInside"
            android:src="@drawable/selector_back_button" />
        <TextView
            android:id="@+id/ConnectStatusTextView"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_centerInParent="true"
            android:text="@string/title_activity_mainactivity"
            android:textColor="@android:color/white"
            android:textSize="21sp" />
    </RelativeLayout>
    <TextView android:id="@+id/version_tv"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Firmware version: N/A"/>
    <ListView
        android:id="@+id/listView"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
</LinearLayout>
In the xml file, firstly, we implement the RelativeLayout element. We declare an ImageButton(id: ReturnBtnMain) element to exit the application, and a TextView(id: ConnectStatusTextView) element to show the connection status text. Next, create a TextView(id:version_tv) element to show the firmware version and a ListView(id:listView) element to show the list items.

在 xml 文件中, 首先, 我们实现了相对元素。 我们声明 ImageButton 元素(id: ReturnBtnMain)元素退出APP, 以及一个文本视图元素(id: ConnectStatusTextView)元素来显示连接状态文本。 接下来, 创建一个 TextView 元素(id: version tv)元素来显示固件版本和一个 ListView 元素来显示列表项。

Next, copy all the image files from this Github sample project to the drawable folders inside the res folder.

接下来, 将 Github 示例项目中的所有图像文件复制到 res 文件夹中的可绘制文件夹。

imageFiles

Moreover, open the AndroidManifest.xml file and update the ".MainActivity" activity element with several attributes as shown below:

此外, 打开 AndroidManifest.xml 文件, 并更新"。 Mainactivity 活动元素具有以下几个属性:

<activity
            android:name=".MainActivity"
            android:configChanges="orientation|screenSize"
            android:label="@string/title_activity_mainactivity"
            android:screenOrientation="landscape"
            android:theme="@android:style/Theme.NoTitleBar.Fullscreen" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
</activity>
Furthermore, open the "strings.xml" file in values folder and add the following string content:

此外, 在值文件夹中打开"stringxml"文件, 并添加以下字符串内容:

<string name="title_activity_mainactivity">P4MissionsDemo</string>
Lastly, let's create a new xml file named "demo_info_item.xml" in the layout folder by right-clicking on the "layout" folder and select New->XML->Layout XML File. Then replace the code of the file with the following:

最后, 让我们创建一个新的 XML 文件, 命名为"演示信息 item.XML", 通过右击"布局"文件夹并选择新的 XML 布局 XML 文件。 然后用以下代码替换文件的代码:

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical" >
    
    <TextView
        android:id="@+id/title"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:textSize="22sp"
        android:layout_marginTop="6dp"
        android:layout_marginBottom="3dp"
        android:layout_marginLeft="10dp"
        android:text="demo title" />
     <TextView 
        android:id="@+id/desc"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:textSize="14sp"
        android:layout_marginBottom="6dp"
        android:layout_marginLeft="10dp"
        android:text="demo desc"
        android:textColor="@color/white"/>
</LinearLayout>
This xml file will help to setup the two TextViews with "title" and "desc" ids for the convertView of DemoListAdapter.

这个 xml 文件将有助于为"DemoListAdapter"的转换视图设置两个带有"title"和"desc"id 的 TextViews。

Now, if you check the activity_main.xml file, you can see the preview screenshot of MainActivity as shown below:

现在, 如果你检查活动 main.xml 文件, 你可以看到 MainActivity 的预览截图如下:


For more details, please check the source code of this tutorial's Github sample project.

有关更多细节, 请检查本教程的 Github 示例项目的源代码。

**4. Creating the PointingTestActivity**
**4. 这是一个很好的示例。 创建 PointingTestActivity**

**Implementing the PointingTestActivity Class**
**实现 PointingTestActivity 类**

Let's create a new Empty Activity class with the name of "PointingTestActivity" in the com.dji.p4MissionsDemo package. Replace the code with the following, remember to import the related classes as Android Studio suggested:

让我们在 com.dji.p4MissionsDemo 包中创建一个名为"PointingTestActivity"的新的空活动类。 用下面的代码替换代码, 记住按照 Android Studio 的建议导入相关的类:

public class PointingTestActivity extends DemoBaseActivity implements TextureView.SurfaceTextureListener, View.OnClickListener {
    private static final String TAG = "PointingTestActivity";
    private ImageButton mPushDrawerIb;
    private SlidingDrawer mPushDrawerSd;
    private Button mStartBtn;
    private ImageButton mStopBtn;
    private TextView mPushTv;
    private RelativeLayout mBgLayout;
    private ImageView mRstPointIv;
    private TextView mAssisTv;
    private Switch mAssisSw;
    private TextView mSpeedTv;
    private SeekBar mSpeedSb;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        setContentView(R.layout.activity_pointing_test);
        super.onCreate(savedInstanceState);
        initUI();
    }
    @Override
    protected void onResume() {
        super.onResume();
    }
    @Override
    protected void onDestroy() {
        super.onDestroy();
    }
    private void initUI() {
        mPushDrawerIb = (ImageButton)findViewById(R.id.pointing_drawer_control_ib);
        mPushDrawerSd = (SlidingDrawer)findViewById(R.id.pointing_drawer_sd);
        mStartBtn = (Button)findViewById(R.id.pointing_start_btn);
        mStopBtn = (ImageButton)findViewById(R.id.pointing_stop_btn);
        mPushTv = (TextView)findViewById(R.id.pointing_push_tv);
        mBgLayout = (RelativeLayout)findViewById(R.id.pointing_bg_layout);
        mRstPointIv = (ImageView)findViewById(R.id.pointing_rst_point_iv);
        mAssisTv = (TextView)findViewById(R.id.pointing_assistant_tv);
        mAssisSw = (Switch)findViewById(R.id.pointing_assistant_sw);
        mSpeedTv = (TextView)findViewById(R.id.pointing_speed_tv);
        mSpeedSb = (SeekBar)findViewById(R.id.pointing_speed_sb);
        mPushDrawerIb.setOnClickListener(this);
        mStartBtn.setOnClickListener(this);
        mStopBtn.setOnClickListener(this);
        mSpeedSb.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
            @Override
            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
                mSpeedTv.setText(progress + 1 + "");
            }
            @Override
            public void onStartTrackingTouch(SeekBar seekBar) {
            }
            @Override
            public void onStopTrackingTouch(SeekBar seekBar) {
            }
        });
    }
    public void onReturn(View view){
        Log.d(TAG, "onReturn");
        this.finish();
    }
    @Override
    public void onClick(View v) {
        if (v.getId() == R.id.pointing_drawer_control_ib) {
            if (mPushDrawerSd.isOpened()) {
                mPushDrawerSd.animateClose();
            } else {
                mPushDrawerSd.animateOpen();
            }
            return;
        }
    }
}
Here, we implement several features:

在这里, 我们实现了几个特性:

1. Declare the UI member variables like ImageButton, TextView, SeekBar, etc. Then override the onCreate() method to invoke the initUI() method to initialize the UI elements of the Activity.

1. 声明 UI 成员变量, 如 ImageButton, TextView, SeekBar 等。 然后重写 onCreate ()方法来调用 initUI ()方法来初始化活动的 UI 元素。

2. In the initUI() method, we create the member variables by invoking the fineViewById() method and passing the related id value declared in the associated layout xml file. Then call the setOnClickListener() method by assigning "this" to it for all the Button member variables. Next implement the SeekBar's setOnSeekBarChangeListener() method and override the three interface methods of OnSeekBarChangeListener. Here we update the text value of SeekBar in the onProgresshanged() method.

第二名。 在 initUI ()方法中, 我们通过调用 fineViewById ()方法创建成员变量, 并传递关联布局 xml 文件中声明的相关 id 值。 然后调用 setOnClickListener ()方法, 将 Button 成员变量的"this"分配给它。 接下来实现 SeekBar 的 setOnSeekBarChangeListener ()方法, 并重写 OnSeekBarChangeListener 的三个接口方法。 这里我们更新了 onProgresshanged ()方法中 SeekBar 的文本值。

3. Lastly, we override the onClick() method to implement the click action of the mPushDrawerIb ImageButton. When you press the mPushDrawerIb, it will add animations when open and close the mPushDrawerSd, which is a SlidingDrawer.

3. 这是一个很好的示例。 最后, 我们重写 onClick ()方法来实现 mphdrawerib ImageButton 的点击操作。 当你按 mphdrawerib 时, 它会在 mphdrawersd 打开和关闭时添加动画, 这是一个 SlidingDrawer。

**Working on PointingTestActivity Layout**
**使用 PointingTestActivity 布局**

Open the colors.xml file in the values folder and replace the content with the following:

在值文件夹中打开 colors.xml 文件, 并以下列方式替换内容:

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="button_normal">#50808080</color>
    <color name="button_press">#5086BFFF</color>
    <color name="white">#FFFFFF</color>
    <color name="black">#000000</color>
</resources>
Here, we add button press and normal colors, white and black colors.

在这里, 我们添加按钮按钮和正常的颜色, 白色和黑色。

Moreover, add the two new string elements to the strings.xml file:

此外, 在 strings.xml 文件中添加两个新的字符串元素:

<string name="push_info">Push Info</string>
<string name="title_activity_pointing_test">TapFly Sample</string>
Then, update the styles.xml with the following code:

然后, 使用以下代码更新样式表

<resources>
    
    <style name="left_button_list_button">
        <item name="android:minHeight">@dimen/left_button_list_button_height</item>
        <item name="android:layout_width">@dimen/left_button_list_button_width</item>
        <item name="android:layout_height">wrap_content</item>
        <item name="android:paddingLeft">@dimen/left_button_list_button_padding_left</item>
        <item name="android:paddingRight">@dimen/left_button_list_button_padding_right</item>
        <item name="android:layout_marginLeft">@dimen/left_button_list_button_margin_left</item>
        <item name="android:layout_marginTop">@dimen/left_button_list_button_margin_top</item>
        <item name="android:background">@drawable/selector_button</item>
        <item name="android:textSize">@dimen/left_button_list_button_text_size</item>
        <item name="android:textColor">@color/white</item>
    </style>
    <!--
        Base application theme, dependent on API level. This theme is replaced
        by AppBaseTheme from res/values-vXX/styles.xml on newer devices.
    -->
    <style name="AppBaseTheme" parent="android:Theme.Light">
        <!--
            Theme customizations available in newer API levels can go in
            res/values-vXX/styles.xml, while customizations related to
            backward-compatibility can go here.
        -->
    </style>
    <!-- Application theme. -->
    <style name="AppTheme" parent="AppBaseTheme">
        <!-- All customizations that are NOT specific to a particular API-level can go here. -->
    </style>
    
    <style name="test_text">
        <item name="android:shadowColor">@color/black</item>
        <item name="android:shadowDx">2</item>
        <item name="android:shadowDy">1</item>
        <item name="android:shadowRadius">6</item>
        <item name="android:textSize">@dimen/test_log_textsize</item>
        <item name="android:textColor">@color/white</item>
    </style>
</resources>
Lastly, jump over to your associated layout in "layout/activity_ pointing_test.xml" file and replace everything with the same xml file from the tutorial's Github Sample Project, since the xml file's content is too much, we don't show them here.

最后, 在"布局 / 活动指向 test.xml"文件中跳转到相关的布局, 用教程中的 Github 示例项目中的 xml 文件替换所有文件, 因为 xml 文件的内容太多了, 我们不会在这里显示它们。

For the UI, we declare a main title, a return button, a connect status text view, a pointing button, etc. Here is a screenshot of the preview of PointingTestActivity:

对于 UI, 我们声明一个主标题, 一个返回按钮, 一个连接状态文本视图, 一个指向按钮等等。 下面是 PointingTestActivity 预览的截图:


**5. Creating the TrackingTestActivity**
**5. 创建 TrackingTestActivity**

**Working on TrackingTestActivity Class**
**工作于 TrackingTestActivity 类**

Once you finish the steps above, let's create a new Empty Activity class with the name of "TrackingTestActivity" in the com.dji.p4MissionsDemo package. Replace the code with the following:

一旦完成上面的步骤, 让我们在 com.dji.p4MissionsDemo 包中创建一个名为"TrackingTestActivity"的新的空活动类。 用以下代码取代代码:

public class TrackingTestActivity extends DemoBaseActivity implements SurfaceTextureListener, OnClickListener, View.OnTouchListener {
    private static final String TAG = "TrackingTestActivity";
    private ImageButton mPushDrawerIb;
    private SlidingDrawer mPushInfoSd;
    private ImageButton mStopBtn;
    private ImageView mTrackingImage;
    private RelativeLayout mBgLayout;
    private TextView mPushInfoTv;
    private TextView mPushBackTv;
    private TextView mGestureModeTv;
    private Switch mPushBackSw;
    private Switch mGestureModeSw;
    private ImageView mSendRectIV;
    private Button mConfigBtn;
    private Button mConfirmBtn;
    private Button mRejectBtn;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        setContentView(R.layout.activity_tracking_test);
        super.onCreate(savedInstanceState);
        initUI();
    }
    private void initUI() {
        mPushDrawerIb = (ImageButton)findViewById(R.id.tracking_drawer_control_ib);
        mPushInfoSd = (SlidingDrawer)findViewById(R.id.tracking_drawer_sd);
        mStopBtn = (ImageButton)findViewById(R.id.tracking_stop_btn);
        mTrackingImage = (ImageView) findViewById(R.id.tracking_rst_rect_iv);
        mBgLayout = (RelativeLayout)findViewById(R.id.tracking_bg_layout);
        mPushInfoTv = (TextView)findViewById(R.id.tracking_push_tv);
        mSendRectIV = (ImageView)findViewById(R.id.tracking_send_rect_iv);
        mPushBackSw = (Switch)findViewById(R.id.tracking_pull_back_sw);
        mPushBackTv = (TextView)findViewById(R.id.tracking_backward_tv);
        mGestureModeTv = (TextView)findViewById(R.id.gesture_mode_tv);
        mGestureModeSw = (Switch)findViewById(R.id.gesture_mode_enable_sw);
        mConfigBtn = (Button)findViewById(R.id.recommended_configuration_btn);
        mConfirmBtn = (Button)findViewById(R.id.confirm_btn);
        mRejectBtn = (Button)findViewById(R.id.reject_btn);
        mStopBtn.setOnClickListener(this);
        mBgLayout.setOnTouchListener(this);
        mPushDrawerIb.setOnClickListener(this);
        mConfigBtn.setOnClickListener(this);
        mConfirmBtn.setOnClickListener(this);
        mRejectBtn.setOnClickListener(this);
    }
    public void onReturn(View view){
        Log.d(TAG, "onReturn");
        this.finish();
    }
    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.tracking_stop_btn:
                break;
            case R.id.tracking_drawer_control_ib:
                if (mPushInfoSd.isOpened()) {
                    mPushInfoSd.animateClose();
                } else {
                    mPushInfoSd.animateOpen();
                }
                break;
            case R.id.recommended_configuration_btn:
                break;
            case R.id.confirm_btn:
                break;
            case R.id.reject_btn:
                break;
            default:
                break;
        }
    }
    @Override
    public boolean onTouch(View v, MotionEvent event) {
        return true;
    }
}
Here, we implement several features:

在这里, 我们实现了几个特性:

1. Declare the UI member variables like ImageButton, SlidingDrawer, SeekBar, etc. Then override the onCreate() method to invoke the initUI() method to initialize the UI elements of the Activity.

1. 声明 UI 成员变量, 如 ImageButton, SlidingDrawer, SeekBar 等。 然后重写 onCreate ()方法来调用 initUI ()方法来初始化活动的 UI 元素。

2. In the initUI() method, we create the member variables by invoking the fineViewById() method and passing the related id value declared in the associated layout xml file. Then call the setOnClickListener() method by assigning "this" to it for all the Button member variables.

第二名。 在 initUI ()方法中, 我们通过调用 fineViewById ()方法创建成员变量, 并传递关联布局 xml 文件中声明的相关 id 值。 然后调用 setOnClickListener ()方法, 将 Button 成员变量的"this"分配给它。

3. Lastly, we override the onClick() method to implement the click action of the mStopBtn, mConfigBtn, mConfirmBtn, mRejectBtn and mPushDrawerIb member variables. When you press the mPushDrawerIb ImageButton, it will add animation to open and close the mPushInfoSd.

3. 这是一个很好的示例。 最后, 我们重写 onClick 方法来实现 mStopBtn、 mConfigBtn、 mConfirmBtn、 mConfirmBtn、 mRejectBtn、 mRejectBtn 和 mphdrawerib 成员变量的单击操作。 当你按 mphdrawerib ImageButton 时, 它会添加动画来打开和关闭 mPushInfoSd。

Next, open the strings.xml file and add the following code:

接下来, 打开 strings.xml 文件, 并添加以下代码:

<string name="title_activity_tracking_test">ActiveTrack Sample</string>
<string name="demo_desc_tracking">ActiveTrack Mission</string>
<string name="demo_desc_pointing">TapFly Mission</string>
Finally, jump over to your associated layout in layout/activity_ tracking_test.xml and replace everything with the same xml file from the tutorial's Github Sample Project, since the xml file's content is a lot, we don't show them here. For more details, please check the related xml file from the Github Sample Project of the demo project.

最后, 在布局 / 活动跟踪 test.xml 中跳转到相关的布局, 并用教程中的 Github 示例项目中的 xml 文件替换所有内容, 因为 xml 文件的内容很多, 我们不会在这里显示它们。 有关更多细节, 请检查演示项目的 Github 示例项目中的相关 xml 文件。

For the UI, we declare a main title, a return button, a connect status text view, a TextureView to show live video stream, an ImageView to show the tracking rectangle, etc. Here is a screenshot of the preview of TrackingTestActivity:

对于 UI, 我们声明一个主标题, 一个返回按钮, 一个连接状态文本视图, 一个显示视频流的 TextureView, 一个 ImageView 来显示跟踪矩形等等。 下面是 TrackingTestActivity 预览版的截图:


**6. Preview the UI of the Application**
**6. 这是一个很好的示例。 预览APP的 UI**

Now, let's open the dimens.xml file and replace the code with the following:

现在, 让我们打开维数 xml 文件, 用下面的代码替换代码:

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- left button list -->
    <dimen name="left_button_list_button_width">150dp</dimen>
    <dimen name="left_button_list_button_height">45dp</dimen>
    <dimen name="left_button_list_button_padding_left">5dp</dimen>
    <dimen name="left_button_list_button_padding_right">5dp</dimen>
    <dimen name="left_button_list_button_margin_left">10dp</dimen>
    <dimen name="left_button_list_button_margin_top">10dp</dimen>
    <dimen name="left_button_list_button_text_size">14sp</dimen>
    
    <dimen name="test_log_textsize">17sp</dimen>
</resources>
Next, open the AndroidManifest.xml file and modify the .PointingTestActivity and .TrackingTestActivity elements as shown below:

接下来, 打开 AndroidManifest.xml 文件, 并修改。 点击测试活动。 跟踪 testactivity 元素如下所示:

<activity
    android:name=".TrackingTestActivity"
    android:label="@string/title_activity_tracking_test"
    android:launchMode="singleInstance"
    android:screenOrientation="landscape"
    android:theme="@android:style/Theme.Holo.NoActionBar.Fullscreen" >
</activity>
<activity
    android:name=".PointingTestActivity"
    android:label="@string/title_activity_pointing_test"
    android:launchMode="singleInstance"
    android:screenOrientation="landscape"
    android:theme="@android:style/Theme.Holo.NoActionBar.Fullscreen" >
</activity>
In the code above, we modify the label, launchMode, screenOrientation and theme attributes for the two Activities.

在上面的代码中, 我们修改了标签, launchMode, screenOrientation 和主题属性。

We have gone through a long process to setup the UI of the application. Now, let's build and run the project and install it in your Android device to test it. If everything goes well, you may see something similar to the following animation:

我们经历了一个很长的过程来设置APP的用户界面。 现在, 让我们建立并运行这个项目, 并把它安装到你的 Android 设备中来测试它。 如果一切顺利, 你可能会看到类似于下面动画的东西:


**Registering the Application**
**登记申请**

After you finish the above steps, let's register our application with the App Key you apply from DJI Developer Website. If you are not familiar with the App Key, please check the Get Started.

完成上述步骤后, 让我们用从 DJI 开发者网站应用的APP密钥来注册我们的APP。 如果您不熟悉APP密钥, 请检查 Get Started。

Now let's open the "AndroidManifest.xml" file and add the following elements above the application element:

现在让我们打开"AndroidManifest.xml"文件, 并在应用元素上面添加以下元素:

<uses-permission android:name="android.permission.BLUETOOTH" />
<uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
<uses-permission android:name="android.permission.VIBRATE" />
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
<uses-permission android:name="android.permission.WAKE_LOCK" />
<uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
<uses-permission android:name="android.permission.CHANGE_WIFI_STATE" />
<uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS" />
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />
<uses-permission android:name="android.permission.READ_PHONE_STATE" />
<uses-feature android:name="android.hardware.camera" />
<uses-feature android:name="android.hardware.camera.autofocus" />
<uses-feature
    android:name="android.hardware.usb.host"
    android:required="false" />
<uses-feature
    android:name="android.hardware.usb.accessory"
    android:required="true" />
<application
    android:name=".MApplication"
    android:allowBackup="true"
    tools:replace="android:icon"
    android:icon="@drawable/ic_launcher"
    android:label="@string/app_name" >
Here, we add uses permissions and uses features for the app. They are required for registration.

在这里, 我们为应用添加使用权限和使用功能。 他们必须登记。

Then add the following elements above the MainActivity activity element:

然后在 MainActivity 活动元素上面添加以下元素:

<!-- DJI SDK -->
        <uses-library android:name="com.android.future.usb.accessory" />
        <meta-data
            android:name="com.dji.sdk.API_KEY"
            android:value="Please enter your App Key here." />
        <activity
            android:name="dji.sdk.sdkmanager.DJIAoaControllerActivity"
            android:theme="@android:style/Theme.Translucent" >
            <intent-filter>
                <action android:name="android.hardware.usb.action.USB_ACCESSORY_ATTACHED" />
            </intent-filter>
            <meta-data
                android:name="android.hardware.usb.action.USB_ACCESSORY_ATTACHED"
                android:resource="@xml/accessory_filter" />
        </activity>
        <service android:name="dji.sdk.sdkmanager.DJIGlobalService" >
        </service>
<!-- DJI SDK -->
In the code above, we enter the App Key of the application under the android:name="com.dji.sdk.API_KEY" attribute. For more details of the "AndroidManifest.xml" file, please check the Github source code of the demo project.

在上面的代码中, 我们输入 android 下APP的APP密钥: name"com.dji.sdk.API Key"属性。 有关"AndroidManifest.xml"文件的更多细节, 请检查演示项目的 Github 源代码。

Since we have implemented the registration logics in the "DJIDemoApplication.java" and "MainActivity.java" files previously, we don't explain the details here.

由于我们先前已在「 DJIDemoApplication.java 」及「 MainActivity.java 」档案中的注册逻辑, 我们不会在此解释详情。

Now, let's build and run the project and install it in your Android device to test it. If everything goes well, you should see the "success" textView like the following screenshot when you register the app successfully.

现在, 让我们建立并运行这个项目, 并把它安装到你的 Android 设备中来测试它。 如果一切顺利, 当你成功地注册APP时, 你应该会看到"成功"文本。

registerSuccess

**Coordinate Transformations for Missions**
**协调任务的转变**

Before we dive into the implementation of two missions, let's learn something about the special coordinate transformations of them.

在我们开始执行两个任务之前, 让我们来了解一下它们的特殊坐标转换。

**TapFly Mission Coordinate Transformation**
**Tapfly 任务协调转换**

If we check the TapFlyExecutionState class, you can see the following two public methods:

如果我们检查 TapFlyExecutionState 类, 你可以看到以下两种公共方法:

public Vector getDirection ()
public PointF getImageLocation ()
1. The getDirection () method returns a DJIVector object, which represents a cartesian vector in 3D space. You can get the actual flying direction of the aircraft using the N-E-D(North-East-Down) coordinate system when the aircraft is executing a TapFly mission.

1. Getdirection 方法返回一个DJI UI Library矢量对象, 它表示3D 空间中的笛卡尔矢量。 当无人机执行 TapFly 飞行任务时, 您可以使用 N-E-D (东北向下)坐标系获得无人机的实际飞行方向。

2. The getImageLocation () method returns a PointF object, which represents the image point from the live video stream where the vision system should calculate the flight direction from. The image point is normalized to [0,1] where (0,0) is the top left corner and (1,1) is the bottom right.

第二名。 方法返回一个 PointF 对象, 该对象表示视觉系统应该计算飞行方向的实时视频流的图像点。 图像点归一化为[0,1] , 其中(0,0)是左上角, (1,1)是右下角。

Here is a diagram to show the coordinate transformation of the mission:

这里有一个图表来显示任务的坐标转换:

tapFlyMissionCoordinate

As the diagram shown above, you can see the process of transformation.

如上图所示, 您可以看到转换的过程。

The target object shown above is transformed from TouchPoint (PointF) to a Video Stream Coordinate System PointF.

上面显示的目标对象从 TouchPoint (PointF)转换为视频流坐标系 PointF。

The getDirection() method shown above belongs to the N-E-D (North-East-Down) Coordinate System and you can invoke this method to get the field value from the SDK.

上面显示的 getDirection 方法属于 N-E-D (North-East-Down)坐标系, 您可以调用此方法从 SDK 获取字段值。

The imageLocation() method shown above belongs to the Video Stream Coordinate System and you can invoke this method to get the field value from the SDK.

上面显示的 imageLocation 方法属于视频流坐标系, 您可以调用此方法从 SDK 获取字段值。

So in our demo application, in order to implement the TapFly mission, we should transform the user's touch location (A PointF object) of Android View Coordinate System into the image location (A PointF object) of Video Stream Coordination System and pass it to the following target object of DJITapFlyMission:

因此, 在我们的演示APP中, 为了实现 TapFly 任务, 我们应该将安卓视图坐标系的触摸位置(PointF 对象)转换为视频流坐标系的图像位置(PointF 对象) , 并将其传递给 DJITapFlyMission 的下列目标对象:

/**
 *  The image point from the video feed where the vision system should calculate the flight direction from. The image point is normalized to [0,1] where (0,0) is the top left corner and (1,1) is the bottom right.
 */
public PointF target

**ActiveTrack Mission Coordinate Transformation**
**活动轨道任务协调转换**

Next, let's check the ActiveTrackTrackingState class, you may see the following public getter method:

接下来, 让我们检查 ActiveTrackTrackingState 类, 您可以看到下面的公共 getter 方法:

public RectF getTargetRect()
Check the ActiveTrackMission class, you can also see this method:

查看 ActiveTrackMission 类, 你还可以看到这个方法:

public void setTargetRect(RectF var1)
1. You can invoke the getTargetRect () method to get a RectF object which is a rectangle in the live video stream view image that represents the target being tracked. The rectangle is normalized to [0,1] where (0,0) is the top left of the video preview and (1,1) is the bottom right.

1. 您可以调用 getargetrect ()方法获取一个 RectF 对象, 它是一个矩形, 在视频流视图中表示被跟踪的目标。 矩形被归一化为[0,1] , 其中(0,0)是视频预览的左上角, (1,1)是右下角。

2. By invoking the setTargetRect(RectF var1) method, you can set the target rect object, which is a RectF class object, it represents a bounding box for the target. The rectangle is normalized to [0,1] where (0,0) is the top left of the video preview and (1,1) is the bottom right.

第二名。 通过调用 setTargetRect (RectF var1)方法, 可以设置目标 rect 对象, 它是一个 RectF 类对象, 它代表了目标的一个包围框。 矩形被归一化为[0,1] , 其中(0,0)是视频预览的左上角, (1,1)是右下角。

If the mission is initialized with a PointF object, the vision system will try to recognize object around the point and return the representative rect in the MissionProgressStatusCallback.

如果使用一个 PointF 对象初始化任务, 视觉系统将尝试识别点周围的对象, 并将代表 rect 返回到 missionprogresprogressstatuscallback 中。

Here is a diagram to show the coordinate transformation of the ActiveTrack mission:

下面的图表显示了 ActiveTrack 任务的坐标转换:

ActiveTrackMissionCoordinate

As the diagram shown above, you can see the process of transformation.

如上图所示, 您可以看到转换的过程。

The 这是一个很好的示例getTargetRect() and 还有setTargetRect(RectF var1) methods shown above belongs to the 以上显示的方法属于Video Stream Coordinate System 视像坐标系.
So in order to implement the ActiveTrack Mission, we should transform the user's touch rect (A RectF object) of Android View Coordinate System into the tracking rect (A RectF object) of Video Stream Coordination System and pass it to the setTargetRect(RectF var1) method of ActiveTrackMission. You can get the tracking rect object by invoking the getTargetRect() method of ActiveTrackTrackingState. And you can use it to update the rectangle on your screen.

因此, 为了实现 ActiveTrack 任务, 我们应该将安卓视图的触摸操作(RectF 对象)转换为视频流坐标系的跟踪 rect (RectF 对象) , 并将其传递到 ActiveTrackMission 的 setTargetRect (RectF var1)方法。 你可以通过调用 ActiveTrackTrackingState 的 getargetrect ()方法获得跟踪 rect 对象。 你可以用它来更新屏幕上的矩形。

**Implementing the TapFly Mission**
**执行 TapFly 任务**

**Updating the DemoBaseActivity**
**更新人员活动**

Before we implement the TapFly Mission, we should update the DemoBaseActivity.java class to configure the live video streaming feature. Let's open the file and add the following codes to it:

在实现 TapFly 任务之前, 我们应该更新 DemoBaseActivity.java 类来配置实时视频流特性。 让我们打开文件并添加下面的代码:

private static final String TAG = MainActivity.class.getName();
protected VideoFeeder.VideoDataCallback mReceivedVideoDataCallBack = null;
protected DJICodecManager mCodecManager = null;
private BaseProduct mProduct;
//To store index chosen in PopupNumberPicker listener
protected static int[] INDEX_CHOSEN = {-1, -1, -1};
protected TextView mConnectStatusTextView;
protected TextureView mVideoSurface = null;
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
     
    IntentFilter filter = new IntentFilter();  
    filter.addAction(DJIDemoApplication.FLAG_CONNECTION_CHANGE);
    registerReceiver(mReceiver, filter);
    mVideoSurface = (TextureView) findViewById(R.id.video_previewer_surface);
    mConnectStatusTextView = (TextView) findViewById(R.id.ConnectStatusTextView);
    if (null != mVideoSurface) {
        mVideoSurface.setSurfaceTextureListener(this);
    }
    // The callback for receiving the raw H264 video data for camera live view
    mReceivedVideoDataCallBack = new VideoFeeder.VideoDataCallback() {
        @Override
        public void onReceive(byte[] videoBuffer, int size) {
            if(mCodecManager != null){
                mCodecManager.sendDataToDecoder(videoBuffer, size);
            }
        }
    };
}
Here we declare a TextureView(mVideoSurface object) to show the live video stream data. We use the video_previewer_surface id from its layout xml file to create the object. This id should be the same as PointingTestActivity and TrackingTestActivity's layout settings. Then create the callback variable mReceivedVideoDataCallBack to implement the DJICamera's interface methods for receiving video data.

在这里, 我们声明一个 TextureView (mVideoSurface 对象)来显示实时视频流数据。 我们使用视频预览器的表面标识从其布局 xml 文件中创建对象。 这个 id 应该与 PointingTestActivity 和 trackingactivity 的布局设置相同。 然后创建回调变量 mReceivedVideoDataCallBack 来实现 DJICamera 接收视频数据的接口方法。

Moreover, we implement the initPreviewer() method as shown below to check product connection status and set the mReceivedVideoDataCallBack as the callback of VideoFeeder:

此外, 我们实现如下所示的 initPreviewer ()方法来检查无人机连接状态, 并将 mReceivedVideoDataCallBack 设置为 VideoFeeder 的回调:

private void initPreviewer() {
    try {
        mProduct = DJIDemoApplication.getProductInstance();
    } catch (Exception exception) {
        mProduct = null;
    }
    
    if (mProduct == null || !mProduct.isConnected()) {
        showToast("Disconnect");
    } else {
        if (null != mVideoSurface) {
            mVideoSurface.setSurfaceTextureListener(this);
        }
        if (!mProduct.getModel().equals(Model.UNKNOWN_AIRCRAFT)) {
            VideoFeeder.getInstance().getPrimaryVideoFeed().setCallback(mReceivedVideoDataCallBack);
        }
    }
}
For more details of the implementation, please check the "DemoBaseActivity.java" file in this tutorial's Github sample project.

有关实现的更多细节, 请在本教程的 Github 示例项目中检查"DemoBaseActivity.java"文件。

**Working on the PointingTestActivity**
**正在进行 PointingTestActivity**

**Showing the Live Video Stream**
**显示实时视频流**

Now let's come back to the "PointingTestActivity.java" class and override the onCreate() method firstly:

现在让我们回到"PointingTestActivity.java"类, 首先重写 onCreate ()方法:

@Override
protected void onCreate(Bundle savedInstanceState) {
    setContentView(R.layout.activity_pointing_test);
    super.onCreate(savedInstanceState);
    initUI();
}
In the method shown above, we invoke the setContentView() method firstly to show the PointingTestActivity view. Then invoke the DemoBaseActivity class's onCreate() method to implement the live video stream showing methods. Lastly, invoke the initUI() to initialize all the UI elements.

在上面所示的方法中, 我们首先调用 setContentView 方法来显示 PointingTestActivity 视图。 然后调用 DemoBaseActivity 类的 onCreate 方法来实现实时视频流显示方法。 最后, 调用 initUI ()来初始化所有 UI 元素。

**Working on the TapFly Mission**
**开展 TapFly 任务**

**Configure Mission**
**配置任务**

Before we start to create the TapFlyMission object, let's use the TapFlyMissionOperator to configure the following settings:

在我们开始创建 TapFlyMission 对象之前, 让我们使用 tapflymissionatoroperator 来配置以下设置:

1. AutoFlightSpeed

1. 自动飞行速度

You can set the aircraft's auto flight speed during the mission by invoking the setAutoFlightSpeed() method of TapFlyMissionOperator. The range for it is [1, 10] m/s.

您可以通过调用 tapflymissionatoroperator 的 setAutoFlightSpeed ()方法来设置飞行任务中的自动飞行速度。 它的范围是[1,10] m / s。

2. isHorizontalObstacleAvoidanceEnabled

第二名。 这些障碍使我们的生活更加美好

If you want to allow the aircraft to bypass or move around an obstacle by going to the left or right of the obstacle when executing TapFly mission, you can set this member variable to YES. Otherwise, the aircraft will only go over an obstacle to avoid it.

如果你想让无人机在执行 TapFly 任务时绕过障碍物的左边或右边来绕过障碍物, 你可以将这个成员变量设置为是。 否则, 无人机只能越过障碍物才能避开它。

3. Target

3. 这是一个很好的示例。 目标

This is where we should pass the coordinate transformation PointF object to, we can use the getTapFlyPoint() method to do the coordinate transformation and return the PointF object. It's the image point from the video feed where the vision system should calculate the flight direction from.

这就是我们应该通过坐标转换 PointF 对象的地方, 我们可以使用 getTapFlyPoint ()方法来进行坐标转换, 并返回 PointF 对象。 它是视觉系统应该计算飞行方向的视频源的图像点。

Now, let's implement the above settings in source code, in the initUI() method, let's improve the setOnSeekBarChangeListener() method of mSpeedSb as shown below:

现在, 让我们在源代码中实现上述设置, 在 initUI ()方法中, 让我们改进 setOnSeekBarChangeListener ()方法, 如下所示:

mSpeedSb.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
    @Override
    public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
        mSpeedTv.setText(progress + 1 + "");
    }
    @Override
    public void onStartTrackingTouch(SeekBar seekBar) {
    }
    @Override
    public void onStopTrackingTouch(SeekBar seekBar) {
        getTapFlyOperator().setAutoFlightSpeed(getSpeed(), new CommonCallbacks.CompletionCallback() {
            @Override
            public void onResult(DJIError error) {
                setResultToToast(error == null ? "Set Auto Flight Speed Success" : error.getDescription());
            }
        });
    }
});
In the code above, we invoke the setAutoFlightSpeed() method of TapFlyMissionOperator in the onStopTrackingTouch() method of setOnSeekBarChangeListener() to configure the auto flight speed for TapFly mission.

在上面的代码中, 我们在 setOnSeekBarChangeListener 的 onStopTrackingTouch ()方法中调用 tapflymissionmissionary 的 setAutoFlightSpeed ()方法来配置 TapFly 任务的自动飞行速度。

Next, let's implement the initTapFlyMission() method to initialize the mTapFlyMission variable and set the isHorizontalObstacleAvoidanceEnabled boolean value as shown below:

接下来, 让我们实现 initTapFlyMission ()方法来初始化 mTapFlyMission 变量, 并将 ishorizontalontalleavoidanceenabled boolean 值设置如下:

private void initTapFlyMission() {
    mTapFlyMission = new TapFlyMission();
    mTapFlyMission.isHorizontalObstacleAvoidanceEnabled = mAssisSw.isChecked();
    mTapFlyMission.tapFlyMode = TapFlyMode.FORWARD;
}
Here we use FORWARD value of the TapFlyMode enum, for more details of the TapFlyMode, please check this documentation.

这里我们使用 TapFlyMode 的 FORWARD 值, 有关 TapFlyMode 的更多细节, 请检查这个文档。

Moreover, let's implement the following two methods to manage the mission coordinate transformations:

此外, 让我们实现以下两种方法来管理任务坐标转换:

private PointF getTapFlyPoint(View iv) {
    if (iv == null) return null;
    View parent = (View)iv.getParent();
    float centerX = iv.getLeft() + iv.getX()  + ((float)iv.getWidth()) / 2;
    float centerY = iv.getTop() + iv.getY() + ((float)iv.getHeight()) / 2;
    centerX = centerX < 0 ? 0 : centerX;
    centerX = centerX > parent.getWidth() ? parent.getWidth() : centerX;
    centerY = centerY < 0 ? 0 : centerY;
    centerY = centerY > parent.getHeight() ? parent.getHeight() : centerY;
    
    return new PointF(centerX / parent.getWidth(), centerY / parent.getHeight());
}
    
private void showPointByTapFlyPoint(final PointF point, final ImageView iv) {
    if (point == null || iv == null) {
        return;
    }
    final View parent = (View)iv.getParent();
     PointingTestActivity.this.runOnUiThread(new Runnable() {
         @Override
         public void run() {
             iv.setX(point.x * parent.getWidth() - iv.getWidth() / 2);
             iv.setY(point.y * parent.getHeight() - iv.getHeight() / 2);
             iv.setVisibility(View.VISIBLE);
             iv.requestLayout();
         }
     });
}
We can use the getTapFlyPoint() method to transform the tap point position of Android View coordinate system to the video stream coordinate system. In contrast, we use the showPointByTapFlyPoint() method to transform the tap point position(We use mRstPointIv to represent it) from video stream coordinate system back to the Android View coordinate system and show it on screen.

我们可以使用 getTapFlyPoint ()方法将 Android 视图坐标系的点击点位置转换为视频流坐标系。 相比之下, 我们使用"pointbytapflypoint"()方法将点击点位置(我们使用 mRstPointIv 来代表它)从视频流坐标系回到 Android 视图坐标系并显示在屏幕上。

Lastly, let's override the onTouch() method to track the ACTION_UP gesture of MotionEvent:

最后, 让我们重写 onTouch ()方法来跟踪 MotionEvent 的 ACTION up 手势:

@Override
public boolean onTouch(View v, MotionEvent event) {
    if (v.getId() == R.id.pointing_bg_layout) {
        
        switch (event.getAction()) {
        case MotionEvent.ACTION_UP:
            if (mTapFlyMission != null) {
                mStartBtn.setVisibility(View.VISIBLE);
                mStartBtn.setX(event.getX() - mStartBtn.getWidth() / 2);
                mStartBtn.setY(event.getY() - mStartBtn.getHeight() / 2);
                mStartBtn.requestLayout();
                mTapFlyMission.target = getTapFlyPoint(mStartBtn);
            } else {
                setResultToToast("TapFlyMission is null");
            }
            break;
        default:
            break;
        }
    }
    return true;
}
Here, we update the mStartBtn's position to the position user press. Then we invoke the getTapFlyPoint() method to do the coordinate transformation and pass it to TapFlyMission's target member variable.

在这里, 我们将 mStartBtn 的位置更新到位置用户按钮。 然后我们调用 getTapFlyPoint 方法来进行坐标转换, 并将其传递给 TapFlyMission 的目标成员变量。

**Start and Stop Mission**
**开始和停止任务**

Next, let's override the onClick() method to implement the click action of mStartBtn and mStopBtn buttons to start and stop the DJITapFlyMission:

接下来, 让我们重写 onClick ()方法来实现 mStartBtn 和 mStopBtn 按钮的单击操作来启动和停止 DJITapFlyMission:

@Override
public void onClick(View v) {
    if (v.getId() == R.id.pointing_drawer_control_ib) {
        if (mPushDrawerSd.isOpened()) {
            mPushDrawerSd.animateClose();
        } else {
            mPushDrawerSd.animateOpen();
        }
        return;
    }
    if (getTapFlyOperator() != null) {
        switch (v.getId()) { 
        case R.id.pointing_start_btn:
            getTapFlyOperator().startMission(mTapFlyMission, new CommonCallbacks.CompletionCallback() {
                @Override
                public void onResult(DJIError error) {
                    setResultToToast(error == null ? "Start Mission Successfully" : error.getDescription());
                    if (error == null){
                        setVisible(mStartBtn, false);
                    }
                }
            });
            break;
        case R.id.pointing_stop_btn:
            getTapFlyOperator().stopMission(new CommonCallbacks.CompletionCallback() {
                @Override
                public void onResult(DJIError error) {
                    setResultToToast(error == null ? "Stop Mission Successfully" : error.getDescription());
                }
            });
            break;
        default:
            break;
        }
    } else {
        setResultToToast("TapFlyMission Operator is null");
    }
}
In the code above, we use a switch statement to identify the mStartBtn and mStopBtn buttons' click action. In the 'mStartBtn' click action case, we invoke the startMission() method of TapFlyMissionOperator to start the mission and update the visibilities of the mStartBtn button.

在上面的代码中, 我们使用 switch 语句来识别 mStartBtn 和 mStopBtn 按钮的点击操作。 在"mStartBtn"的单击操作示例中, 我们调用 TapFlyMissionOperator. 的 startMission ()方法来启动任务并更新 mStartBtn 按钮的可视性。

In the mStopBtn click action case, we invoke the stopMission() method of TapFlyMissionOperator to stop the mission.

在 mStopBtn 点击操作案例中, 我们调用 TapFlyMissionOperator. 的 stopMission 方法来停止任务。

**Add Listener to Receive Mission Events**
**添加侦听器以接收任务事件**

During the TapFly mission execution, we can add a listener to receive the mission events for status infos. You can use this status infos to inform users of the results or update the UI interface.

在 TapFly 任务执行期间, 我们可以添加一个侦听器来接收状态信息的任务事件。 您可以使用这个状态信息表通知用户结果或更新用户界面。

Now, let's add the following code at the bottom of onCreate() method:

现在, 让我们在 onCreate ()方法的底部添加下面的代码:

@Override
protected void onCreate(Bundle savedInstanceState) {
    setContentView(R.layout.activity_pointing_test);
    super.onCreate(savedInstanceState);
    initUI();
    getTapFlyOperator().addListener(new TapFlyMissionOperatorListener() {
        @Override
        public void onUpdate(@Nullable TapFlyMissionEvent aggregation) {
            TapFlyExecutionState executionState = aggregation.getProgressState();
            if (executionState != null){
                showPointByTapFlyPoint(executionState.getImageLocation(), mRstPointIv);
            }
            StringBuffer sb = new StringBuffer();
            String errorInformation = (aggregation.getError() == null ? "null" : aggregation.getError().getDescription()) + "\n";
            String currentState = aggregation.getCurrentState() == null ? "null" : aggregation.getCurrentState().getName();
            String previousState = aggregation.getPreviousState() == null ? "null" : aggregation.getPreviousState().getName();
            Utils.addLineToSB(sb, "CurrentState: ", currentState);
            Utils.addLineToSB(sb, "PreviousState: ", previousState);
            Utils.addLineToSB(sb, "Error:", errorInformation);
            TapFlyExecutionState progressState = aggregation.getProgressState();
            if (progressState != null) {
                Utils.addLineToSB(sb, "Heading: ", progressState.getRelativeHeading());
                Utils.addLineToSB(sb, "PointX: ", progressState.getImageLocation().x);
                Utils.addLineToSB(sb, "PointY: ", progressState.getImageLocation().y);
                Utils.addLineToSB(sb, "BypassDirection: ", progressState.getBypassDirection().name());
                Utils.addLineToSB(sb, "VectorX: ", progressState.getDirection().getX());
                Utils.addLineToSB(sb, "VectorY: ", progressState.getDirection().getY());
                Utils.addLineToSB(sb, "VectorZ: ", progressState.getDirection().getZ());
                setResultToText(sb.toString());
            }
            TapFlyMissionState missionState = aggregation.getCurrentState();
            if (!((missionState == TapFlyMissionState.EXECUTING) || (missionState == TapFlyMissionState.EXECUTION_PAUSED)
                    || (missionState == TapFlyMissionState.EXECUTION_RESETTING))){
                setVisible(mRstPointIv, false);
                setVisible(mStopBtn, false);
            }else
            {
                setVisible(mStopBtn, true);
                setVisible(mStartBtn, false);
            }
        }
    });
}
In the code above, we implement the following features:

在上面的代码中, 我们实现了以下特性:

Invoke the 调用addListener() method of 的方法TapFlyMissionOperator and implement the 并且实现onUpdate() method to receive the TapFly mission events. 收到 TapFly 任务事件的方法
In the 在美国onUpdate() method, we firstly get the 方法, 我们首先得到TapFlyExecutionState object 对象executionState from the updated 更新后的aggregation variable. Next, check if the 变量。 接下来, 检查一下executionState is null, if not, invoke the 如果不是, 则调用showPointByTapFlyPoint() method to update the position of the 方法来更新mRstPointIv image View (A green circle) on screen. This green circle represents the direction which Mavic Pro will fly towards. 图像视图(绿色圆圈)在屏幕上。 这个绿色圆圈代表了 Mavic Pro 将要飞向的方向
Moreover, store the TapFly execution state infos into the StringBuffer 此外, 将 TapFly 的执行状态信息存储到 StringBuffer 中sb and show it on the 然后在mPushTv TextView. 文本视图
Lastly, we get the updated 最后, 我们得到更新TapFlyMissionState and set visible property for 并设置可见属性mRstPointIv, mStartBtn and 还有mStopBtn.
For more implementation details of the PointingTestActivity class, please check the Github source code.

有关 PointingTestActivity 类的更多实现细节, 请检查 Github 源代码。

Now let's build and run the project to install the app to your Android device, if everything goes well, you should be able to use the TapFly mission of Mavic Pro now.

现在, 让我们建立并运行一个项目, 把这个应用安装到你的安卓设备上, 如果一切顺利, 你现在应该可以使用 Mavic Pro 的 TapFly 任务了。

Important: Remember to switch the remote controller to P mode before you test the TapFly mission.

重要的: 在你测试 TapFly 任务之前, 请记住将遥控器切换到 p 模式。

Here is a gif animation for you to get a better understanding of using the TapFly mission feature:

下面是一个 gif 动画, 让你更好地理解 TapFly 的使命特色:


In the animation, when you tap on the screen, a green circle with a "GO" button appears, which is the direction you want Mavic Pro fly towards. Then, press the GO button, Mavic Pro will start to execute the TapFly mission and fly. When you want to stop the mission, just press the X button, Mavic Pro will stop immediately and hover there.

在动画中, 当你点击屏幕时, 会出现一个带有"GO"按钮的绿色圆圈, 这就是你想让 Mavic Pro 飞向的方向。 然后, 按下 GO 按钮, Mavic Pro 将开始执行 TapFly 任务并飞行。 当你想停止任务的时候, 只要按下 x 键, Mavic Pro 就会立即停止并在那里盘旋。

**Implementing ActiveTrack Mission**
**执行 ActiveTrack 任务**

**Working on the TrackingTestActivity**
**正在进行 TrackingTestActivity**

**Showing the Live Video Stream**
**显示实时视频流**

Now let's go to TrackingTestActivity.java class and override the onCreate() method firstly:

现在让我们先去 TrackingTestActivity.java 类, 首先重写 onCreate ()方法:

@Override
protected void onCreate(Bundle savedInstanceState) {
    setContentView(R.layout.activity_tracking_test);
    super.onCreate(savedInstanceState);
    initUI();
}
In the method shown above, we invoke the setContentView() method firstly to show the TrackingTestActivity view. Then invoke the DemoBaseActivity class's onCreate() method to implement the live video stream showing methods. Lastly, invoke the initUI() to initialize all the UI elements.

在上面的方法中, 我们首先调用 setContentView 方法来显示 TrackingTestActivity 视图。 然后调用 DemoBaseActivity 类的 onCreate 方法来实现实时视频流显示方法。 最后, 调用 initUI ()来初始化所有 UI 元素。

**Working on the ActiveTrack Mission**
**执行 ActiveTrack 任务**

**Configure Mission**
**配置任务**

Before we start to create the ActiveTrackMission object, let's use the ActiveTrackOperator to configure the following settings:

在开始创建 ActiveTrackMission 对象之前, 让我们使用 ActiveTrackOperator 来配置以下设置:

Enable/Disable Gesture Mode 启用 / 禁用手势模式
Gesture mode allows the subject to confirm tracking as well as take pictures using gestures. Raise your arms in a V, the human subject can accept the confirmation to track them. Gesture mode can only be enabled when the aircraft is flying but not tracking a target. If the aircraft is already tracking a target, disabling gesture mode will stop the ActiveTrack mission.

手势模式允许主体确认跟踪, 以及使用手势拍照。 举起你的手臂在一个 v, 人类主体可以接受确认来跟踪他们。 只有当无人机在飞行, 而不是跟踪目标时, 才能启用手势模式。 如果无人机已经在跟踪目标, 那么禁用手势模式将停止 ActiveTrack 任务。

You can check this video to get a better understanding of the Gesture Mode.

你可以检查这个视频, 以便更好地理解手势模式。

Now let's implement the setChecked() and setOnCheckedChangeListener() methods of the mGestureModeSw switch at the bottom of the initUI() method as shown below:

现在让我们来实现 setChecked ()和 setOnCheckedChangeListener ()方法, 如下所示:

mGestureModeSw.setChecked(getActiveTrackOperator().isGestureModeEnabled());
mGestureModeSw.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener()
{
    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked)
    {
        getActiveTrackOperator().setGestureModeEnabled(isChecked, new CommonCallbacks.CompletionCallback() {
            @Override
            public void onResult(DJIError error) {
                setResultToToast("Set GestureMode Enabled: " + (error == null
                        ? "Success"
                        : error.getDescription()));
            }
        });
    }
});
In the code above, we firstly invoke the isGestureModeEnabled() method of ActiveTrackOperator to check if the gesture mode is enabled and update the value of the mGestureModeSw switch. Next, invoke the setGestureModeEnabled() method of ActiveTrackOperator to set the gesture mode and inform users by showing a toast message in the completion callback.

在上面的代码中, 我们首先调用 activetracktrackoperator 的 isGestureModeEnabled 方法来检查手势模式是否启用, 并更新 mGestureModeSw 开关的值。 接下来, 调用 ActiveTrackOperator 的 setGestureModeEnabled 方法来设置手势模式, 通过在完成回调中显示 toast 消息来通知用户。

Enable/Disable Retreat 启用 / 禁用撤退
When retreat is enabled, the aircraft will retreat (fly backwards) when the target comes toward it. When it is disabled, the aircraft will not retreat and instead rotate the gimbal pitch down to track the target as it goes underneath. If the target goes beyond the gimbal's pitch stop, the target will be lost and the mission will stop.

当能够撤退的时候, 当目标飞向它时, 无人机会退缩(向后飞)。 当无人机失灵时, 无人机不会撤退, 而是旋转平衡球, 以便在目标下降时跟踪它。 如果目标超出了平衡杆的停止, 目标就会丢失, 任务就会停止。

Here, let's implement the setOnCheckedChangeListener() method of the mPushBackSw switch at the bottom of the initUI() method as shown below:

这里, 让我们来实现在 initUI ()方法底部的 mPushBackSw 开关的 setOnCheckedChangeListener 方法, 如下所示:

mPushBackSw.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener()
{
    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked)
    {
        getActiveTrackOperator().setRetreatEnabled(isChecked, new CommonCallbacks.CompletionCallback() {
            @Override
            public void onResult(DJIError error) {
                setResultToToast("Set RetreatEnabled: " + (error == null
                        ? "Success"
                        : error.getDescription()));
            }
        });
    }
});
As you see the code above, we invoke the setRetreatEnabled() method of ActiveTrackOperator to enable the retreat feature. Next, in the completion callback, inform users by showing a toast message.

当您看到上面的代码时, 我们调用 activetracktrackoperator 的 setRetreatEnabled 方法来启用撤退特性。 接下来, 在完成回调中, 通过显示 toast 消息来告知用户。

Set Recommended Configuration 设置推荐配置
Using this feature, we can set the recommended camera and gimbal configuration that optimizes performance for the ActiveTrack Mission in most environments.

使用这一特性, 我们可以设置推荐的摄像头和平衡环配置, 以优化 ActiveTrack 任务在大多数环境中的性能。

Now, let's implement the onClick() method of the mConfigBtn button as shown below:

现在, 让我们来实现如下所示的 mConfigBtn 按钮的 onClick 方法:

case R.id.recommended_configuration_btn:
    getActiveTrackOperator().setRecommendedConfiguration(new CommonCallbacks.CompletionCallback() {
        @Override
        public void onResult(DJIError error) {
            setResultToToast("Set Recommended Config" + (error == null ? "Success" : error.getDescription()));
        }
    });
    break;
Here, we can invoke the setRecommendedConfiguration() method of ActiveTrackOperator to set the recommended camera and gimbal configuration. Then in the completion callback, show a toast message to inform users of the results.

在这里, 我们可以调用 ActiveTrackOperator 的 setRecommendedConfiguration ()方法来设置推荐的摄像头和平衡环配置。 然后在完成回调时, 显示 toast 消息以告知用户结果。

**Start the Mission**
**开始执行任务**

Once you finish the steps above, let's continue to implement the following methods to start the ActiveTrack mission:

一旦完成上面的步骤, 让我们继续实现以下方法来启动 ActiveTrack 任务:

private RectF getActiveTrackRect(View iv) {
    View parent = (View)iv.getParent();
    return new RectF(
            ((float)iv.getLeft() + iv.getX()) / (float)parent.getWidth(),
            ((float)iv.getTop() + iv.getY()) / (float)parent.getHeight(),
            ((float)iv.getRight() + iv.getX()) / (float)parent.getWidth(),
            ((float)iv.getBottom() + iv.getY()) / (float)parent.getHeight()
    );
}
private double calcManhattanDistance(double point1X, double point1Y, double point2X, double point2Y) {
    return Math.abs(point1X - point2X) + Math.abs(point1Y - point2Y);
}
@Override
public boolean onTouch(View v, MotionEvent event) {
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            isDrawingRect = false;
            downX = event.getX();
            downY = event.getY();
            break;
        case MotionEvent.ACTION_MOVE:
            if (calcManhattanDistance(downX, downY, event.getX(), event.getY()) < 20 && !isDrawingRect) {
                return true;
            }
            isDrawingRect = true;
            mSendRectIV.setVisibility(View.VISIBLE);
            int l = (int)(downX < event.getX() ? downX : event.getX());
            int t = (int)(downY < event.getY() ? downY : event.getY());
            int r = (int)(downX >= event.getX() ? downX : event.getX());
            int b = (int)(downY >= event.getY() ? downY : event.getY());
            mSendRectIV.setX(l);
            mSendRectIV.setY(t);
            mSendRectIV.getLayoutParams().width = r - l;
            mSendRectIV.getLayoutParams().height = b - t;
            mSendRectIV.requestLayout();
            break;
        case MotionEvent.ACTION_UP:
            RectF rectF = getActiveTrackRect(mSendRectIV);
            PointF pointF = new PointF(downX / mBgLayout.getWidth(), downY / mBgLayout.getHeight());
            RectF pointRectF = new RectF(pointF.x, pointF.y, 0, 0);
            mActiveTrackMission = isDrawingRect ? new ActiveTrackMission(rectF, ActiveTrackMode.TRACE) :
                    new ActiveTrackMission(pointRectF, ActiveTrackMode.TRACE);
            getActiveTrackOperator().startTracking(mActiveTrackMission, new CommonCallbacks.CompletionCallback() {
                @Override
                public void onResult(DJIError error) {
                    setResultToToast("Start Tracking: " + (error == null
                                ? "Success"
                                : error.getDescription()));
                }
            });
            mSendRectIV.setVisibility(View.INVISIBLE);
            break;
        default:
            break;
    }
    return true;
}
In the code above, we implement the following features:

在上面的代码中, 我们实现了以下特性:

In the getActiveTrackRect() method, we transform the tracking rectangle of Android View coordinate system to the video stream coordinate system. 在 getActiveTrackRect ()方法中, 我们将 Android 视图坐标系的跟踪矩形转换为视频流坐标系
Next, in the 接下来calcManhattanDistance() method, we calculate the Manhattan distance between two points when drawing rect on the screen. 方法, 我们计算曼哈顿两点之间的距离时, 在屏幕上绘制 rect
Moreover, we implement the 此外, 我们实现了onTouch() method to handle the 如何处理ACTION_DOWN, ACTION_MOVE and 还有ACTION_UP MotionEvents. In the 运动项目。 在美国ACTION_DOWN and 还有ACTION_MOVE events, we mainly work on updating the size and position of the white 我们主要致力于更新白色的大小和位置mSendRectIV rectangle on screen when user draws. 当用户在屏幕上绘制矩形时
In the 在美国ACTION_UP event, we firstly invoke the 事件, 我们首先调用getActiveTrackRect() method and pass the 方法, 并通过mSendRectIV variable to transform the drawing rectangle to the video stream coordinate system. Next, check the value of the 变量将绘图矩形转换为视频流坐标系。 接下来, 检查一下isDrawingRect and initialize the 然后初始化mActiveTrackMission variable accordingly. Here, we use the 相应地变化。 在这里, 我们使用TRACE mode of the 的模式ActiveTrackMode. Furthermore, invoke the . 此外, 请调用startTracking() method of 的方法ActiveTrackOperator to start the ActiveTrack mission and inform users by showing a toast message. Lastly, we hide the 启动 ActiveTrack 任务并通过显示 toast 消息来通知用户。 最后, 我们隐藏了mSendRectIV image view. 图像视图

**Accept and Reject Confirmation**
**接受和拒绝确认**

When the vision system is not sure if the tracking rectangle is around the user's desired target, it will need confirmation before starting to fly relative to the target. Let's implement the onClick() method of the mConfirmBtn button as shown below:

当视觉系统不确定跟踪矩形是否围绕用户的预期目标时, 它将需要确认, 然后开始相对于目标飞行。 让我们实现 mconfirmtn 按钮的 onClick ()方法, 如下所示:

case R.id.confirm_btn:
    getActiveTrackOperator().acceptConfirmation(new CommonCallbacks.CompletionCallback() {
        @Override
        public void onResult(DJIError error) {
            setResultToToast(error == null ? "Accept Confirm Success!" : error.getDescription());
        }
    });
    break;
Here, we invoke the acceptConfirmation() method of ActiveTrackOperator to accept the confirmation and show a toast message to inform users of the results.

在这里, 我们调用 ActiveTrackOperator 的接受确认方法来接受确认, 并显示 toast 消息以通知用户结果。

If you want to stop the aircraft from following the target, and ask for user's confirmation again, you can implement the onClick() method of the mRejectBtn button as shown below:

如果你想阻止无人机跟踪目标, 并再次要求用户确认, 可以实现 mRejectBtn 按钮的 onClick ()方法, 如下图所示:

case R.id.reject_btn:
    getActiveTrackOperator().rejectConfirmation(new CommonCallbacks.CompletionCallback() {
        @Override
        public void onResult(DJIError error) {
            setResultToToast(error == null ? "Reject Confirm Success!" : error.getDescription());
        }
    });
    break;
In the code above, we invoke the rejectConfirmation() method of ActiveTrackOperator to reject the confirmation and stop the aircraft from following the target. Then show a toast message to inform users of the results.

在上面的代码中, 我们调用 ActiveTrackOperator 的拒绝确认方法来拒绝确认并阻止无人机跟踪目标。 然后展示一个祝酒词, 告诉用户结果。

**Add Listener to Receive Mission Events**
**添加侦听器以接收任务事件**

During the ActiveTrack mission execution, we can add a listener to receive the mission events for status infos. You can use this status infos to inform users of the results or update the UI interface.

在 ActiveTrack 任务执行期间, 我们可以添加一个侦听器来接收状态信息的任务事件。 您可以使用这个状态信息表通知用户结果或更新用户界面。

Now, let's implement the ActiveTrackMissionOperatorListener interface and add the following code at the bottom of the onCreate() method:

现在, 让我们实现 ActiveTrackMissionOperatorListener 接口, 并在 onCreate ()方法的底部添加以下代码:

@Override
protected void onCreate(Bundle savedInstanceState) {
    setContentView(R.layout.activity_tracking_test);
    super.onCreate(savedInstanceState);
    initUI();
    getActiveTrackOperator().addListener(this);
}
Here we add TrackingTestActivity as the listener to receive mission events. Next, let's implement the updateActiveTrackRect() method and onUpdate callback method as shown below:

这里我们添加了 TrackingTestActivity 作为接收任务事件的侦听器。 接下来, 让我们实现 updateActiveTrackRect ()方法和 onUpdate 回调方法, 如下所示:

private void updateActiveTrackRect(final ImageView iv, final ActiveTrackMissionEvent event) {
    if (iv == null || event == null) return;
    View parent = (View)iv.getParent();
    if (event.getTrackingState() != null){
        RectF trackingRect = event.getTrackingState().getTargetRect();
        final int l = (int)((trackingRect.centerX() - trackingRect.width() / 2) * parent.getWidth());
        final int t = (int)((trackingRect.centerY() - trackingRect.height() / 2) * parent.getHeight());
        final int r = (int)((trackingRect.centerX() + trackingRect.width() / 2) * parent.getWidth());
        final int b = (int)((trackingRect.centerY() + trackingRect.height() / 2) * parent.getHeight());
        TrackingTestActivity.this.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                ActiveTrackTargetState targetState = event.getTrackingState().getState();
                if ((targetState == ActiveTrackTargetState.CANNOT_CONFIRM)
                        || (targetState == ActiveTrackTargetState.UNKNOWN))
                {
                    iv.setImageResource(R.drawable.visual_track_cannotconfirm);
                } else if (targetState == ActiveTrackTargetState.WAITING_FOR_CONFIRMATION) {
                    iv.setImageResource(R.drawable.visual_track_needconfirm);
                } else if (targetState == ActiveTrackTargetState.TRACKING_WITH_LOW_CONFIDENCE){
                    iv.setImageResource(R.drawable.visual_track_lowconfidence);
                } else if (targetState == ActiveTrackTargetState.TRACKING_WITH_HIGH_CONFIDENCE){
                    iv.setImageResource(R.drawable.visual_track_highconfidence);
                }
                iv.setVisibility(View.VISIBLE);
                iv.setX(l);
                iv.setY(t);
                iv.getLayoutParams().width = r - l;
                iv.getLayoutParams().height = b - t;
                iv.requestLayout();
            }
        });
    }
}
@Override
public void onUpdate(ActiveTrackMissionEvent event) {
    StringBuffer sb = new StringBuffer();
    String errorInformation = (event.getError() == null ? "null" : event.getError().getDescription()) + "\n";
    String currentState = event.getCurrentState() == null ? "null" : event.getCurrentState().getName();
    String previousState = event.getPreviousState() == null ? "null" : event.getPreviousState().getName();
    Utils.addLineToSB(sb, "CurrentState: ", currentState);
    Utils.addLineToSB(sb, "PreviousState: ", previousState);
    Utils.addLineToSB(sb, "Error:", errorInformation);
    ActiveTrackTrackingState trackingState = event.getTrackingState();
    if (trackingState != null){
        RectF trackingRect = trackingState.getTargetRect();
        if (trackingRect != null) {
            Utils.addLineToSB(sb, "Rect center x: ", trackingRect.centerX());
            Utils.addLineToSB(sb, "Rect center y: ", trackingRect.centerY());
            Utils.addLineToSB(sb, "Rect Width: ", trackingRect.width());
            Utils.addLineToSB(sb, "Rect Height: ", trackingRect.height());
            Utils.addLineToSB(sb, "Reason", trackingState.getReason().name());
            Utils.addLineToSB(sb, "Target Index: ", trackingState.getTargetIndex());
            Utils.addLineToSB(sb, "Target Type", trackingState.getType().name());
            Utils.addLineToSB(sb, "Target State", trackingState.getState().name());
            setResultToText(sb.toString());
        }
    }
    updateActiveTrackRect(mTrackingImage, event);
    ActiveTrackState state = event.getCurrentState();
    if (state == ActiveTrackState.FINDING_TRACKED_TARGET ||
            state == ActiveTrackState.AIRCRAFT_FOLLOWING ||
            state == ActiveTrackState.ONLY_CAMERA_FOLLOWING ||
                    state == ActiveTrackState.CANNOT_CONFIRM ||
                    state == ActiveTrackState.WAITING_FOR_CONFIRMATION ||
                    state == ActiveTrackState.PERFORMING_QUICK_SHOT){
        TrackingTestActivity.this.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                mStopBtn.setVisibility(View.VISIBLE);
                mStopBtn.setClickable(true);
                mConfirmBtn.setVisibility(View.VISIBLE);
                mConfirmBtn.setClickable(true);
                mRejectBtn.setVisibility(View.VISIBLE);
                mRejectBtn.setClickable(true);
                mConfigBtn.setVisibility(View.INVISIBLE);
            }
        });
    }else
    {
        TrackingTestActivity.this.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                mStopBtn.setVisibility(View.INVISIBLE);
                mStopBtn.setClickable(false);
                mConfirmBtn.setVisibility(View.INVISIBLE);
                mConfirmBtn.setClickable(false);
                mRejectBtn.setVisibility(View.INVISIBLE);
                mRejectBtn.setClickable(false);
                mConfigBtn.setVisibility(View.VISIBLE);
                mTrackingImage.setVisibility(View.INVISIBLE);
            }
        });
    }
}
In the code above, we implement the following features:

在上面的代码中, 我们实现了以下特性:

In the 在美国updateActiveTrackRect() method, we update the 方法, 我们更新mTrackingImage image view's position and size based on the current target rect. Also, update the image resource of the 图像视图的位置和大小, 基于目前的目标 rect。 同时, 更新图片资源mTrackingImage variable based on the 变量, 基于ActiveTrackTargetState.
Next, in the 接下来onUpdate() method, we create a StringBuffer 方法, 创建一个 StringBuffersb object and store the ActiveTrack execution state infos into it and show it on the 对象并存储 ActiveTrack 执行状态信息, 并显示在mPushInfoTv TextView. 文本视图
Moreover, invoke the 此外, 请调用updateActiveTrackRect() method to update the position of the 方法来更新mTrackingImage image View (A rectangle with different colors) on screen base on the updated 图像视图(不同颜色的矩形)在屏幕上基于更新ActiveTrackMissionEvent.
Lastly, get the updated 最后, 获得更新ActiveTrackState object and update the UI interfaces' 对象并更新用户界面visibility 能见度 and 还有clickable 可以点击 status. 状态

**Stop the Mission**
**停止使命**

Lastly, let's continue to implement the onClick() method of the mStopBtn button as shown below:

最后, 让我们继续实现 mStopBtn 按钮的 onClick 方法, 如下所示:

case R.id.tracking_stop_btn:
    getActiveTrackOperator().stopTracking(new CommonCallbacks.CompletionCallback() {
        @Override
        public void onResult(DJIError error) {
            setResultToToast(error == null ? "Stop Tracking Success!" : error.getDescription());
        }
    });
    break;
Here, we invoke the stopTracking() method of ActiveTrackOperator to stop executing the ActiveTrack mission and show a toast message to inform users of the result.

在这里, 我们调用 ActiveTrackOperator 的 stopTracking 方法, 停止执行 ActiveTrack 任务, 并显示 toast 消息以通知用户结果。

For more implementation details of the TrackingTestActivity.java file, please check this tutorial's Github source code.

有关 TrackingTestActivity.java 文件的更多实现细节, 请检查本教程的 Github 源代码。

Now let's build and run the project, if everything goes well, you should be able to use the ActiveTrack mission of Mavic Pro now.

现在让我们建立和运行这个项目, 如果一切顺利的话, 你应该可以使用 Mavic Pro 的 ActiveTrack 任务。

Important: Remember to switch the remote controller to P mode before you test the ActiveTrack mission.

重要内容: 在测试 ActiveTrack 任务之前, 请记住将遥控器切换到 p 模式。

Here are two gif animations for you to get a better understanding of using the ActiveTrack mission:

下面是两个 gif 动画, 让你更好地理解 ActiveTrack 的使命:

TRACE Mode 跟踪模式

Here we use the TRACE mode of ActiveTrackMode for demonstration. In the animation above, you can see there is a person riding a bicycle there, you can touch the screen to draw a white rectangle on him. Then the rectangle locks on him and turns purple when the ActiveTrackTargetState is WAITING_FOR_CONFIRMATION. Press the A button to accept the confirmation. After the confirmation, the rectangle turns green and the ActiveTrack mission starts. The person rides around and the green rectangle will follow him to track its movement.

这里我们使用 ActiveTrackMode 的 TRACE 模式来演示。 在上面的动画中, 你可以看到有人在那里骑自行车, 你可以触摸屏幕画一个白色的矩形。 当 ActiveTrackTargetState 等待确认时, 矩形锁定了他, 变成紫色。 按 a 键接受确认。 确认后, 矩形变绿, ActiveTrack 任务开始。 骑马的人和绿色的长方形会跟着他去追踪它的移动。

Press the X button if you want to stop the ActiveTrack mission. By the way, you can try to switch on the "RetreatEnabled" switcher on the upper left corner of the screen to enable the Retreat feature. Once you go towards the Mavic Pro, it will fly backwards.

如果你想停止 ActiveTrack 任务, 请按 x 键。 顺便说一下, 你可以尝试切换到屏幕左上角的"RetreatEnabled"切换器, 以启用撤退功能。 一旦你走向 Mavic Pro, 它就会向后飞。

Enable Gesture Mode 启用手势模式

In the animation above, you can see there is a person standing there, when he raise his arms in a V, the Mavic Pro will accept the confirmation and start to track him automatically. Press the X button if you want to stop the ActiveTrack mission.

在上面的动画中, 你可以看到有一个人站在那里, 当他举起他的胳膊在 v, 御亲会接受确认, 并开始跟踪他自动。 如果你想停止 ActiveTrack 任务, 请按 x 键。

**Using the DJI Assistant 2 for Mission Testing**
**使用 DJI 助手2进行任务测试**

Since most of our developers don't have a perfect testing environment, like a big indoor space, wide backyard, etc. If we need to go outdoors and bring our laptop to debug and test our application everytime, it's time-consuming and not efficient.

因为我们的大多数开发者没有一个完美的测试环境, 比如一个大的室内空间, 宽阔的后院等等。 如果我们需要到户外去, 把我们的笔记本电脑调试和测试我们的APP, 那么它是耗费时间的, 而且效率不高。

Luckily, we have a new DJI Assistant 2 (Includes the 3D Simulator) for you to test the mission easily on your Mac. The simulator creates a virtual 3D environment from flight data transmitted to the Mac.

幸运的是, 我们有一个新的 DJI 助手2(包括3D 模拟器) , 让你可以在 Mac 上轻松地测试任务。 模拟器通过传输到 Mac 的飞行数据创建了一个虚拟的3D 环境。

You can check the Using DJI Assistant 2 Simulator for its basic usage.

您可以检查使用 DJI 助手2模拟器的基本用法。

Now you can connect your Android which is running the demo application to the remote controller, and start to test the TapFly and ActiveTrack missions on the simulator of DJI Assistant 2.

现在, 您可以将正在将演示APP运行到遥控器的安卓系统连接起来, 并开始在 DJI 助手2的模拟器上测试 指点飞行和智能跟随 任务。

By the way, you can use Wireless Android Debug Bridge (adb) to debug the app using Android Studio when your android device is connecting to the remote controller. If you are not familiar with Android Debug Bridge, please check this link for details.

顺便说一下, 当你的安卓设备连接到遥控器时, 你可以使用无线 Android 调试桥梁(adb)来调试APP。 如果您不熟悉 Android Debug Bridge, 请检查此链接以获取详细信息。

**Summary**
**摘要**

Congratulations! You've finished the demo project and implement the two cool TapFly and ActiveTrack missions using DJI Mobile SDK. It's easy and straightforward. You've learned how to use the DJITapFlyMission, DJIActiveTrackMission and DJIMissionControl to implement the features.

恭喜你！ 您已经完成了演示项目, 并使用 DJI Mobile SDK 实现了两个酷的 指点飞行和智能跟随 任务。 这很简单, 也很简单。 您已经学习如何使用 DJITapFlyMission, DJIActiveTrackMission 和 DJIMissionControl 来实现这些功能。

But, In order to make a cool TapFly and ActiveTrack mission application, you still have a long way to go. You can add more necessary features like showing the battery percentage, GPS signal quality, add a checklist like DJI Go app to check the aircraft status before flying, etc. Good luck and hope you enjoy this tutorial!

但是, 为了制作一个酷酷的 指点飞行和智能跟随 任务APP, 你还有很长的路要走。 你可以添加更多必要的功能, 比如显示电池比例, GPS 信号重量, 添加一个清单, 如 DJI Go APP, 在飞行之前检查无人机状态等等。 祝你好运, 希望你喜欢这个教程！


如果您觉得文档翻译有不妥，欢迎到Github上发起push请求，
如果你觉得本文档对您有帮助，可以通过赞赏来帮助我持续维护文档
也可以扫描下面的二维码加我微信拉您进DJI Mobile SDK 开发者群 探讨DJI SDK开发相关问题
![](images/20180303_092058.jpg)